filename,path,content,is_binary
computertools.csv,/,"filename,path,content,is_binary",false
ComputerTools,/exe/,"#!/usr/bin/env ruby

lib_dir = File.expand_path(File.join(__dir__, "".."", ""lib""))
$:.unshift lib_dir unless $:.include?(lib_dir)

require ""ComputerTools""

ComputerTools::CLI.start(ARGV)",false
blueprint_config_action.rb,/lib/ComputerTools/actions/blueprint/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    # Manages the application's configuration through a command-line interface.
    # This action allows users to show, set up, test, and reset the configuration,
    # which is stored in a YAML file. It handles settings for the database,
    # AI provider, editor, and various feature flags.
    #
    # @example Show the current configuration
    #   ComputerTools::Actions::BlueprintConfigAction.new(subcommand: 'show').call
    #
    # @example Run the interactive setup
    #   ComputerTools::Actions::BlueprintConfigAction.new(subcommand: 'setup').call
    class BlueprintConfigAction < Sublayer::Actions::Base
      # The path to the YAML file where configuration is stored.
      CONFIG_PATH = File.join(__dir__, '..', 'config', 'blueprints.yml')

      ##
      # Initializes the configuration action.
      #
      # @param subcommand [String] The configuration command to execute.
      #   Defaults to 'show'. Supported values: 'show', 'view', 'setup',
      #   'init', 'edit', 'test', 'reset'.
      def initialize(subcommand: 'show')
        @subcommand = subcommand
      end

      ##
      # Executes the specified configuration subcommand.
      #
      # This is the main entry point for the action. It routes to the appropriate
      # method based on the subcommand provided during initialization. It also
      # includes error handling to catch and report issues during execution.
      #
      # @return [Boolean] Returns `true` on success and `false` on failure or
      #   if an unknown subcommand is provided.
      def call
        case @subcommand
        when 'show', 'view'
          show_configuration
        when 'setup', 'init', 'edit'
          setup_configuration
        when 'test'
          test_configuration
        when 'reset'
          reset_configuration
        else
          ComputerTools.logger.failure(""Unknown config subcommand: '#{@subcommand}'"")
          show_config_help
          false
        end
      rescue StandardError => e
        ComputerTools.logger.failure(""Error managing configuration: #{e.message}"")
        ComputerTools.logger.debug(e) # tty-logger will format the exception and backtrace
        false
      end

      private

      ##
      # Displays the current configuration settings.
      #
      # Reads from the configuration file and prints a formatted summary of all
      # settings, including database, AI, editor, and feature flags. Also shows
      # the status of relevant environment variables.
      #
      # @return [Boolean] Returns `true`.
      def show_configuration
        config = load_configuration

        ComputerTools.logger.step(""Blueprint Configuration"")
        puts ""="" * 60
        puts ""Config file: #{CONFIG_PATH}""
        puts ""File exists: #{File.exist?(CONFIG_PATH) ? 'Yes' : 'No'}""
        puts """"

        if config
          puts ""Database Configuration:"".colorize(:cyan)
          puts ""  URL: #{mask_password(config.dig('database', 'url') || 'Not set')}""
          puts """"

          puts ""AI Configuration:"".colorize(:cyan)
          puts ""  Provider: #{config.dig('ai', 'provider') || 'Not set'}""
          puts ""  Model: #{config.dig('ai', 'model') || 'Not set'}""
          puts ""  API Key: #{config.dig('ai', 'api_key') ? 'Set' : 'Not set'}""
          puts """"

          puts ""Editor Configuration:"".colorize(:cyan)
          puts ""  Editor: #{config.dig('editor') || 'Not set'}""
          puts ""  Auto-save: #{config.dig('auto_save_edits') || 'Not set'}""
          puts """"

          puts ""Feature Flags:"".colorize(:cyan)
          puts ""  Auto-description: #{config.dig('features', 'auto_description') || 'Not set'}""
          puts ""  Auto-categorization: #{config.dig('features', 'auto_categorize') || 'Not set'}""
          puts ""  Debug mode: #{config.dig('debug') || 'Not set'}""
        else
          ComputerTools.logger.failure(""No configuration found"")
          ComputerTools.logger.tip(""Run 'blueprint config setup' to create configuration"")
        end

        puts ""="" * 60
        puts """"

        # Show environment variables
        show_environment_variables

        true
      end

      ##
      # Runs an interactive setup process for configuration.
      #
      # Prompts the user for all necessary configuration values, such as database
      # URL, AI provider/model, and editor preferences. It then saves the
      # resulting configuration to the YAML file.
      #
      # @return [Boolean] Returns `true` if the configuration is saved
      #   successfully, `false` otherwise.
      def setup_configuration
        ComputerTools.logger.step(""Blueprint Configuration Setup"")
        puts ""="" * 50
        puts """"

        config = load_configuration || {}

        # Database configuration
        puts ""üìä Database Configuration"".colorize(:cyan)
        current_db = config.dig('database', 'url') || 'postgres://localhost/blueprints_development'
        db_url = prompt_for_input(""Database URL"", current_db)

        config['database'] = { 'url' => db_url }

        # AI configuration
        puts ""\nü§ñ AI Configuration"".colorize(:cyan)
        current_provider = config.dig('ai', 'provider') || 'gemini'
        provider = prompt_for_choice(""AI Provider"", ['gemini', 'openai'], current_provider)

        current_model = config.dig('ai', 'model') || (provider == 'gemini' ? 'text-embedding-004' : 'text-embedding-3-small')
        model = prompt_for_input(""AI Model"", current_model)

        puts ""üí° Set API key via environment variable:"".colorize(:yellow)
        puts ""   export GEMINI_API_KEY=your_key_here"" if provider == 'gemini'
        puts ""   export OPENAI_API_KEY=your_key_here"" if provider == 'openai'

        config['ai'] = {
          'provider' => provider,
          'model' => model
        }

        # Editor configuration
        puts ""\n‚úèÔ∏è  Editor Configuration"".colorize(:cyan)
        current_editor = config.dig('editor') || ENV['EDITOR'] || ENV['VISUAL'] || 'vim'
        editor = prompt_for_input(""Preferred editor"", current_editor)

        current_auto_save = config.dig('auto_save_edits')
        auto_save = prompt_for_boolean(""Auto-save edits"", current_auto_save.nil? || current_auto_save)

        config['editor'] = editor
        config['auto_save_edits'] = auto_save

        # Feature flags
        puts ""\nüéõÔ∏è  Feature Configuration"".colorize(:cyan)
        current_auto_desc = config.dig('features', 'auto_description')
        auto_desc = prompt_for_boolean(""Auto-generate descriptions"", current_auto_desc.nil? || current_auto_desc)

        current_auto_cat = config.dig('features', 'auto_categorize')
        auto_cat = prompt_for_boolean(""Auto-generate categories"", current_auto_cat.nil? || current_auto_cat)

        current_debug = config.dig('debug')
        debug = prompt_for_boolean(""Debug mode"", current_debug || false)

        config['features'] = {
          'auto_description' => auto_desc,
          'auto_categorize' => auto_cat
        }
        config['debug'] = debug

        # Save configuration
        puts ""\nüíæ Saving Configuration"".colorize(:blue)
        save_success = save_configuration(config)

        if save_success
          ComputerTools.logger.success(""Configuration saved successfully!"", file: CONFIG_PATH)
          ComputerTools.logger.tip(""Run 'blueprint config test' to validate the configuration"")
        else
          ComputerTools.logger.failure(""Failed to save configuration"")
        end

        save_success
      end

      ##
      # Tests the validity and connectivity of the current configuration.
      #
      # Checks the database connection, AI provider API key, and editor
      # availability based on the settings in the configuration file.
      #
      # @return [Boolean] Returns `true` if all tests pass, `false` otherwise.
      def test_configuration
        ComputerTools.logger.step(""Testing Blueprint Configuration"")
        puts ""="" * 50

        config = load_configuration
        unless config
          ComputerTools.logger.failure(""No configuration found"")
          return false
        end

        all_tests_passed = true

        # Test database connection
        puts ""\nüìä Testing database connection..."".colorize(:cyan)
        db_success = test_database_connection(config)
        all_tests_passed &&= db_success

        # Test AI API
        puts ""\nü§ñ Testing AI API connection..."".colorize(:cyan)
        ai_success = test_ai_connection(config)
        all_tests_passed &&= ai_success

        # Test editor
        puts ""\n‚úèÔ∏è  Testing editor availability..."".colorize(:cyan)
        editor_success = test_editor(config)
        all_tests_passed &&= editor_success

        puts ""\n"" + (""="" * 50)
        if all_tests_passed
          ComputerTools.logger.success(""All configuration tests passed!"")
        else
          ComputerTools.logger.failure(""Some configuration tests failed"")
          ComputerTools.logger.tip(""Run 'blueprint config setup' to fix issues"")
        end

        all_tests_passed
      end

      ##
      # Deletes the configuration file, resetting to defaults.
      #
      # Prompts the user for confirmation before deleting the `blueprints.yml` file.
      #
      # @return [Boolean] Returns `true` if the file is deleted or if it didn't
      #   exist initially. Returns `false` if the user cancels the operation.
      def reset_configuration
        if File.exist?(CONFIG_PATH)
          print ""‚ö†Ô∏è  This will delete the existing configuration. Continue? (y/N): ""
          response = STDIN.gets.chomp.downcase

          if ['y', 'yes'].include?(response)
            File.delete(CONFIG_PATH)
            ComputerTools.logger.success(""Configuration reset successfully"")
            ComputerTools.logger.tip(""Run 'blueprint config setup' to create new configuration"")
            true
          else
            ComputerTools.logger.warn(""Reset cancelled"")
            false
          end
        else
          ComputerTools.logger.info(""No configuration file found to reset"")
          true
        end
      end

      ##
      # Displays help text for the configuration command.
      # @return [nil]
      def show_config_help
        puts <<~HELP
          Blueprint Configuration Commands:

          blueprint config show     Show current configuration
          blueprint config setup    Interactive configuration setup
          blueprint config test     Test configuration connectivity
          blueprint config reset    Reset configuration to defaults

          Configuration is stored in: #{CONFIG_PATH}
        HELP
      end

      ##
      # Loads the configuration from the YAML file.
      #
      # @return [Hash, nil] A hash containing the configuration, or `nil` if the
      #   file does not exist or an error occurs during loading.
      def load_configuration
        return nil unless File.exist?(CONFIG_PATH)

        YAML.load_file(CONFIG_PATH)
      rescue StandardError => e
        ComputerTools.logger.warn(""Error loading configuration: #{e.message}"")
        nil
      end

      ##
      # Saves the given configuration hash to the YAML file.
      #
      # Ensures the directory exists before writing the file.
      #
      # @param config [Hash] The configuration hash to save.
      # @return [Boolean] `true` on successful save, `false` otherwise.
      def save_configuration(config)
        # Ensure directory exists
        config_dir = File.dirname(CONFIG_PATH)
        FileUtils.mkdir_p(config_dir) unless Dir.exist?(config_dir)

        File.write(CONFIG_PATH, config.to_yaml)
        true
      rescue StandardError => e
        ComputerTools.logger.failure(""Error saving configuration: #{e.message}"")
        false
      end

      ##
      # Displays the status of relevant environment variables.
      # @return [void]
      def show_environment_variables
        puts ""üåç Environment Variables:"".colorize(:blue)

        env_vars = {
          'GEMINI_API_KEY' => ENV.fetch('GEMINI_API_KEY', nil),
          'OPENAI_API_KEY' => ENV.fetch('OPENAI_API_KEY', nil),
          'BLUEPRINT_DATABASE_URL' => ENV.fetch('BLUEPRINT_DATABASE_URL', nil),
          'DATABASE_URL' => ENV.fetch('DATABASE_URL', nil),
          'EDITOR' => ENV.fetch('EDITOR', nil),
          'VISUAL' => ENV.fetch('VISUAL', nil)
        }

        env_vars.each do |key, value|
          status = value ? 'Set' : 'Not set'
          puts ""  #{key}: #{status}""
        end
        puts """"
      end

      ##
      # Tests the database connection using the URL from the configuration.
      #
      # @param config [Hash] The loaded configuration hash.
      # @return [Boolean] `true` if the connection is successful, `false` otherwise.
      def test_database_connection(config)
        require 'sequel'
        db_url = config.dig('database', 'url')
        db = Sequel.connect(db_url)
        db.test_connection
        ComputerTools.logger.success(""Database connection successful"")
        true
      rescue StandardError => e
        ComputerTools.logger.failure(""Database connection failed: #{e.message}"")
        false
      end

      ##
      # Tests the AI provider connection by checking for an API key.
      #
      # This is a simplified test that only checks if the relevant environment
      # variable for the configured provider is set.
      #
      # @param config [Hash] The loaded configuration hash.
      # @return [Boolean] `true` if the API key is found, `false` otherwise.
      def test_ai_connection(config)
        # This is a simplified test - in reality you'd make an actual API call
        provider = config.dig('ai', 'provider')
        api_key = case provider
                  when 'gemini'
                    ENV.fetch('GEMINI_API_KEY', nil)
                  when 'openai'
                    ENV.fetch('OPENAI_API_KEY', nil)
                  end

        if api_key
          ComputerTools.logger.success(""AI API key found for #{provider}"")
          true
        else
          ComputerTools.logger.failure(""AI API key not found for #{provider}"")
          false
        end
      end

      ##
      # Tests if the configured editor is available in the system's PATH.
      #
      # @param config [Hash] The loaded configuration hash.
      # @return [Boolean] `true` if the editor command is found, `false` otherwise.
      def test_editor(config)
        editor = config.dig('editor')
        if system(""which #{editor} > /dev/null 2>&1"")
          ComputerTools.logger.success(""Editor '#{editor}' found"")
          true
        else
          ComputerTools.logger.failure(""Editor '#{editor}' not found"")
          false
        end
      end

      ##
      # Prompts the user for text input via STDIN.
      #
      # @param prompt [String] The message to display to the user.
      # @param default [String, nil] The default value to use if the user enters nothing.
      # @return [String] The user's input or the default value.
      def prompt_for_input(prompt, default=nil)
        print ""#{prompt}""
        print "" [#{default}]"" if default
        print "": ""

        input = STDIN.gets.chomp
        input.empty? ? default : input
      end

      ##
      # Prompts the user to select from a list of choices.
      #
      # @param prompt [String] The message to display to the user.
      # @param choices [Array<String>] A list of available options.
      # @param default [String, nil] The default choice if the user enters nothing.
      # @return [String] The user's selection or the default value.
      def prompt_for_choice(prompt, choices, default=nil)
        puts ""#{prompt} (#{choices.join('/')})""
        print default ? ""[#{default}]: "" : "": ""

        input = STDIN.gets.chomp
        input.empty? ? default : input
      end

      ##
      # Prompts the user for a boolean (yes/no) response.
      #
      # @param prompt [String] The message to display to the user.
      # @param default [Boolean, nil] The default value (`true`, `false`, or `nil`)
      #   to use if the user enters nothing.
      # @return [Boolean, nil] Returns `true` for 'y', `false` for 'n', or the
      #   default value for any other input.
      def prompt_for_boolean(prompt, default=nil)
        default_text = case default
                       when true then ' [Y/n]'
                       when false then ' [y/N]'
                       else ' [y/n]'
                       end

        print ""#{prompt}#{default_text}: ""
        input = STDIN.gets.chomp.downcase

        case input
        when 'y', 'yes', 'true'
          true
        when 'n', 'no', 'false'
          false
        else
          default
        end
      end

      ##
      # Masks the password portion of a database URL for safe display.
      #
      # @param url [String] The database URL to process.
      # @return [String] The URL with the password replaced by '***'.
      def mask_password(url)
        return url unless url.include?(':') && url.include?('@')

        url.gsub(/:[^:@]*@/, ':***@')
      end
    end
  end
end",false
blueprint_delete_action.rb,/lib/ComputerTools/actions/blueprint/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class BlueprintDeleteAction < Sublayer::Actions::Base
      def initialize(id: nil, force: false)
        @id = id
        @force = force
        @db = ComputerTools::Wrappers::BlueprintDatabase.new
      end

      def call
        # If no ID provided, show interactive selection
        if @id.nil?
          @id = select_blueprint_interactively
          return false unless @id
        end

        # Fetch the blueprint to delete
        blueprint = @db.get_blueprint(@id)
        unless blueprint
          puts ""‚ùå Blueprint #{@id} not found"".colorize(:red)
          return false
        end

        # Show blueprint details and confirm deletion
        return false if !@force && !confirm_deletion?(blueprint)

        # Perform the deletion
        puts ""üóëÔ∏è  Deleting blueprint..."".colorize(:yellow)

        if @db.delete_blueprint(@id)
          puts ""‚úÖ Blueprint '#{blueprint[:name]}' (ID: #{@id}) deleted successfully"".colorize(:green)
          true
        else
          puts ""‚ùå Failed to delete blueprint"".colorize(:red)
          false
        end
      rescue StandardError => e
        puts ""‚ùå Error deleting blueprint: #{e.message}"".colorize(:red)
        puts e.backtrace.first(3).join(""\n"") if ENV['DEBUG']
        false
      end

      private

      def select_blueprint_interactively
        puts ""üîç Loading blueprints for selection..."".colorize(:blue)

        blueprints = @db.list_blueprints(limit: 50)

        if blueprints.empty?
          puts ""‚ùå No blueprints found"".colorize(:red)
          return nil
        end

        puts ""\nSelect a blueprint to delete:""
        puts ""="" * 60

        blueprints.each_with_index do |blueprint, index|
          categories = blueprint[:categories].map { |c| c[:title] }.join(', ')
          puts ""#{index + 1}. #{blueprint[:name]} (ID: #{blueprint[:id]})""
          puts ""   Description: #{blueprint[:description]}""
          puts ""   Categories: #{categories}"" unless categories.empty?
          puts ""   Created: #{blueprint[:created_at]}""
          puts """"
        end

        print ""Enter the number of the blueprint to delete (1-#{blueprints.length}), or 'q' to quit: ""
        response = $stdin.gets.chomp

        if response.downcase == 'q'
          puts ""‚ùå Operation cancelled"".colorize(:yellow)
          return nil
        end

        index = response.to_i - 1
        if index >= 0 && index < blueprints.length
          blueprints[index][:id]
        else
          puts ""‚ùå Invalid selection"".colorize(:red)
          nil
        end
      end

      def confirm_deletion?(blueprint)
        puts ""\n#{'=' * 60}""
        puts ""üóëÔ∏è  Blueprint Deletion Confirmation"".colorize(:red)
        puts ""="" * 60
        puts ""ID: #{blueprint[:id]}""
        puts ""Name: #{blueprint[:name]}""
        puts ""Description: #{blueprint[:description]}""

        categories = blueprint[:categories].map { |c| c[:title] }.join(', ')
        puts ""Categories: #{categories}"" unless categories.empty?

        puts ""Created: #{blueprint[:created_at]}""
        puts ""Updated: #{blueprint[:updated_at]}""
        puts ""Code length: #{blueprint[:code].length} characters""
        puts """"

        # Show first few lines of code as preview
        code_lines = blueprint[:code].lines
        puts ""Code preview (first 5 lines):""
        code_lines.first(5).each_with_index do |line, i|
          puts ""  #{i + 1}: #{line.chomp}""
        end
        puts ""  ..."" if code_lines.length > 5
        puts """"

        puts ""‚ö†Ô∏è  WARNING: This action cannot be undone!"".colorize(:yellow)
        puts ""The blueprint and all its metadata will be permanently deleted."".colorize(:yellow)
        puts """"

        print ""Are you sure you want to delete this blueprint? (y/N): ""
        response = $stdin.gets.chomp.downcase

        if ['y', 'yes'].include?(response)
          puts ""‚úÖ Deletion confirmed"".colorize(:green)
          true
        else
          puts ""‚ùå Deletion cancelled"".colorize(:yellow)
          false
        end
      end
    end
  end
end",false
blueprint_edit_action.rb,/lib/ComputerTools/actions/blueprint/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class BlueprintEditAction < Sublayer::Actions::Base
      def initialize(id:)
        @id = id
        @db = ComputerTools::Wrappers::BlueprintDatabase.new
      end

      def call
        # Step 1: Fetch the current blueprint
        blueprint = @db.get_blueprint(@id)
        unless blueprint
          puts ""‚ùå Blueprint #{@id} not found"".colorize(:red)
          return false
        end

        puts ""‚úèÔ∏è  Editing blueprint: #{blueprint[:name]}"".colorize(:blue)
        puts ""Original description: #{blueprint[:description]}""
        puts ""Categories: #{blueprint[:categories].map { |c| c[:title] }.join(', ')}"" if blueprint[:categories].any?

        # Step 2: Open editor with current code
        temp_file = create_temp_file(blueprint)

        begin
          # Step 3: Launch editor
          editor_success = launch_editor(temp_file)
          unless editor_success
            puts ""‚ùå Editor failed or was cancelled"".colorize(:red)
            return false
          end

          # Step 4: Read modified content
          modified_code = File.read(temp_file)

          # Step 5: Check if content actually changed
          if modified_code.strip == blueprint[:code].strip
            puts ""‚ÑπÔ∏è  No changes detected"".colorize(:blue)
            return true
          end

          puts ""‚úÖ Changes detected"".colorize(:green)

          # Step 6: Confirm the edit operation
          unless confirm_edit_operation(blueprint, modified_code)
            puts ""‚ùå Edit operation cancelled"".colorize(:yellow)
            return false
          end

          # Step 7: Execute delete-and-resubmit workflow
          perform_delete_and_resubmit(blueprint, modified_code)
        ensure
          # Clean up temporary file
          File.delete(temp_file) if File.exist?(temp_file)
        end
      rescue StandardError => e
        puts ""‚ùå Error during edit operation: #{e.message}"".colorize(:red)
        puts e.backtrace.first(3).join(""\n"") if ENV['DEBUG']
        false
      end

      private

      def create_temp_file(blueprint)
        # Detect file extension based on code content
        extension = detect_file_extension(blueprint[:code])

        # Create safe filename
        safe_name = blueprint[:name].gsub(/[^a-zA-Z0-9_-]/, '_').downcase
        temp_file = Tempfile.new([""blueprint_#{@id}_#{safe_name}"", extension])
        temp_file.write(blueprint[:code])
        temp_file.flush
        temp_file.path
      end

      def detect_file_extension(code)
        case code
        when /class\s+\w+.*<.*ApplicationRecord/m, /def\s+\w+.*end/m, /require ['""].*['""]/m
          '.rb'
        when /function\s+\w+\s*\(/m, /const\s+\w+\s*=/m, /import\s+.*from/m
          '.js'
        when /def\s+\w+\s*\(/m, /import\s+\w+/m, /from\s+\w+\s+import/m
          '.py'
        when /#include\s*<.*>/m, /int\s+main\s*\(/m
          '.c'
        when /public\s+class\s+\w+/m, /import\s+java\./m
          '.java'
        when /fn\s+\w+\s*\(/m, /use\s+std::/m
          '.rs'
        when /func\s+\w+\s*\(/m, /package\s+main/m
          '.go'
        else
          '.txt'
        end
      end

      def launch_editor(temp_file)
        # Get editor preference from config or environment
        editor = get_editor_preference

        puts ""üîß Opening #{editor} with blueprint code..."".colorize(:cyan)
        puts ""üí° Save and exit when done editing"".colorize(:cyan)

        # Launch editor and wait for it to complete
        system(""#{editor} #{temp_file}"")
      end

      def get_editor_preference
        # Check configuration file
        config_file = File.join(__dir__, '..', 'config', 'blueprints.yml')
        if File.exist?(config_file)
          config = YAML.load_file(config_file)
          editor = config.dig('editor')
          return editor if editor
        end

        # Fall back to environment variables
        ENV['EDITOR'] || ENV['VISUAL'] || 'vim'
      end

      def confirm_edit_operation(original_blueprint, modified_code)
        puts ""\n"" + (""="" * 60)
        puts ""üîÑ Edit Operation Confirmation"".colorize(:blue)
        puts ""="" * 60
        puts ""Original blueprint: #{original_blueprint[:name]} (ID: #{@id})""
        puts ""Original code length: #{original_blueprint[:code].length} characters""
        puts ""Modified code length: #{modified_code.length} characters""
        puts """"
        puts ""‚ö†Ô∏è  WARNING: This will:"".colorize(:yellow)
        puts ""   1. DELETE the existing blueprint (including embeddings)"".colorize(:yellow)
        puts ""   2. CREATE a new blueprint with the modified code"".colorize(:yellow)
        puts ""   3. Generate NEW embeddings for better search"".colorize(:yellow)
        puts """"

        # Show a preview of changes
        show_change_preview(original_blueprint[:code], modified_code)

        print ""Continue with edit operation? (y/N): ""
        response = STDIN.gets.chomp.downcase
        ['y', 'yes'].include?(response)
      end

      def show_change_preview(original_code, modified_code)
        puts ""üìã Change Preview:"".colorize(:cyan)

        # Show first and last few lines to give context
        original_lines = original_code.lines
        modified_lines = modified_code.lines

        puts ""Original (first 3 lines):""
        original_lines.first(3).each_with_index do |line, i|
          puts ""  #{i + 1}: #{line.chomp}""
        end

        puts ""\nModified (first 3 lines):""
        modified_lines.first(3).each_with_index do |line, i|
          puts ""  #{i + 1}: #{line.chomp}""
        end

        if original_lines.length != modified_lines.length
          puts ""\nLine count changed: #{original_lines.length} ‚Üí #{modified_lines.length}"".colorize(:yellow)
        end

        puts """"
      end

      def perform_delete_and_resubmit(original_blueprint, modified_code)
        puts ""üîÑ Starting delete-and-resubmit workflow..."".colorize(:blue)

        # Store original metadata for rollback
        original_data = {
          name: original_blueprint[:name],
          description: original_blueprint[:description],
          categories: original_blueprint[:categories].map { |c| c[:title] }
        }

        # Step 1: Delete the existing blueprint
        puts ""üóëÔ∏è  Deleting original blueprint..."".colorize(:yellow)
        delete_success = @db.delete_blueprint(@id)

        unless delete_success
          puts ""‚ùå Failed to delete original blueprint. Aborting edit."".colorize(:red)
          return false
        end

        puts ""‚úÖ Original blueprint deleted"".colorize(:green)

        # Step 2: Submit the modified code as a new blueprint
        puts ""üìù Creating new blueprint with modified code..."".colorize(:yellow)

        submit_action = ComputerTools::Actions::BlueprintSubmitAction.new(
          code: modified_code,
          name: original_data[:name], # Keep original name initially
          description: nil, # Let AI regenerate description for modified code
          categories: original_data[:categories], # Keep original categories initially
          auto_describe: true,
          auto_categorize: false # Keep original categories unless user wants new ones
        )

        new_blueprint_success = submit_action.call

        if new_blueprint_success
          puts ""‚úÖ Edit operation completed successfully!"".colorize(:green)
          puts ""üí° The blueprint now has fresh embeddings for improved search"".colorize(:cyan)
          true
        else
          puts ""‚ùå Failed to create new blueprint"".colorize(:red)
          puts ""‚ö†Ô∏è  Original blueprint has been deleted and cannot be restored"".colorize(:red)
          puts ""üí° You may need to manually recreate the blueprint"".colorize(:yellow)
          false
        end
      end
    end
  end
end",false
blueprint_export_action.rb,/lib/ComputerTools/actions/blueprint/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class BlueprintExportAction < Sublayer::Actions::Base
      def initialize(id:, output_path: nil, include_metadata: false)
        @id = id
        @output_path = output_path
        @include_metadata = include_metadata
        @db = ComputerTools::Wrappers::BlueprintDatabase.new
      end

      def call
        puts ""üì§ Exporting blueprint #{@id}..."".colorize(:blue)
        
        blueprint = @db.get_blueprint(@id)
        unless blueprint
          puts ""‚ùå Blueprint #{@id} not found"".colorize(:red)
          return false
        end

        # Generate output path if not provided
        @output_path ||= generate_output_path(blueprint)
        
        # Check if file already exists
        if File.exist?(@output_path)
          unless confirm_overwrite
            puts ""‚ùå Export cancelled"".colorize(:yellow)
            return false
          end
        end

        # Export the blueprint
        export_success = export_blueprint(blueprint)
        
        if export_success
          puts ""‚úÖ Blueprint exported to: #{@output_path}"".colorize(:green)
          show_export_summary(blueprint)
          true
        else
          puts ""‚ùå Failed to export blueprint"".colorize(:red)
          false
        end
      rescue => e
        puts ""‚ùå Error exporting blueprint: #{e.message}"".colorize(:red)
        puts e.backtrace.first(3).join(""\n"") if ENV['DEBUG']
        false
      end

      private

      def generate_output_path(blueprint)
        # Create safe filename from blueprint name
        safe_name = (blueprint[:name] || 'blueprint').gsub(/[^a-zA-Z0-9_-]/, '_').downcase
        extension = detect_file_extension(blueprint[:code])
        
        base_filename = ""#{safe_name}_#{@id}#{extension}""
        
        # Check if file exists and add number suffix if needed
        counter = 1
        output_path = base_filename
        
        while File.exist?(output_path)
          name_part = File.basename(base_filename, extension)
          output_path = ""#{name_part}_#{counter}#{extension}""
          counter += 1
        end
        
        output_path
      end

      def detect_file_extension(code)
        case code
        when /class\s+\w+.*<.*ApplicationRecord/m, /def\s+\w+.*end/m, /require ['""].*['""]/m
          '.rb'
        when /function\s+\w+\s*\(/m, /const\s+\w+\s*=/m, /import\s+.*from/m
          '.js'
        when /def\s+\w+\s*\(/m, /import\s+\w+/m, /from\s+\w+\s+import/m
          '.py'
        when /#include\s*<.*>/m, /int\s+main\s*\(/m
          '.c'
        when /public\s+class\s+\w+/m, /import\s+java\./m
          '.java'
        when /fn\s+\w+\s*\(/m, /use\s+std::/m
          '.rs'
        when /func\s+\w+\s*\(/m, /package\s+main/m
          '.go'
        when /<\?php/m, /namespace\s+\w+/m
          '.php'
        when /<!DOCTYPE html/mi, /<html/mi
          '.html'
        when /^#!/m
          '' # Script files often have no extension
        else
          '.txt'
        end
      end

      def confirm_overwrite
        print ""‚ö†Ô∏è  File '#{@output_path}' already exists. Overwrite? (y/N): ""
        response = STDIN.gets.chomp.downcase
        response == 'y' || response == 'yes'
      end

      def export_blueprint(blueprint)
        content = build_export_content(blueprint)
        
        begin
          # Ensure directory exists
          dir = File.dirname(@output_path)
          FileUtils.mkdir_p(dir) unless Dir.exist?(dir)
          
          # Write the file
          File.write(@output_path, content)
          true
        rescue => e
          puts ""‚ùå Failed to write file: #{e.message}"".colorize(:red)
          false
        end
      end

      def build_export_content(blueprint)
        if @include_metadata
          build_content_with_metadata(blueprint)
        else
          blueprint[:code]
        end
      end

      def build_content_with_metadata(blueprint)
        content = []
        
        # Add metadata as comments based on file type
        comment_style = get_comment_style(@output_path)
        
        content << format_comment(""Blueprint Export"", comment_style)
        content << format_comment(""="" * 50, comment_style)
        content << format_comment(""ID: #{blueprint[:id]}"", comment_style)
        content << format_comment(""Name: #{blueprint[:name]}"", comment_style)
        content << format_comment(""Description: #{blueprint[:description]}"", comment_style)
        
        if blueprint[:categories] && blueprint[:categories].any?
          category_names = blueprint[:categories].map { |cat| cat[:title] }
          content << format_comment(""Categories: #{category_names.join(', ')}"", comment_style)
        end
        
        content << format_comment(""Exported: #{Time.now}"", comment_style)
        content << format_comment(""="" * 50, comment_style)
        content << """"
        content << blueprint[:code]
        
        content.join(""\n"")
      end

      def get_comment_style(filename)
        case File.extname(filename).downcase
        when '.rb', '.py', '.sh'
          '#'
        when '.js', '.java', '.c', '.cpp', '.cs', '.go', '.rs', '.php'
          '//'
        when '.html', '.xml'
          '<!--'
        when '.css'
          '/*'
        else
          '#'
        end
      end

      def format_comment(text, style)
        case style
        when '<!--'
          ""<!-- #{text} -->""
        when '/*'
          ""/* #{text} */""
        else
          ""#{style} #{text}""
        end
      end

      def show_export_summary(blueprint)
        puts ""\nüìã Export Summary:"".colorize(:blue)
        puts ""   Blueprint: #{blueprint[:name]} (ID: #{@id})""
        puts ""   File: #{@output_path}""
        puts ""   Size: #{File.size(@output_path)} bytes""
        puts ""   Format: #{@include_metadata ? 'Code with metadata' : 'Code only'}""
        
        if blueprint[:categories] && blueprint[:categories].any?
          category_names = blueprint[:categories].map { |cat| cat[:title] }
          puts ""   Categories: #{category_names.join(', ')}""
        end
        
        puts """"
        puts ""üí° Tip: Use --include-metadata flag to export with blueprint information"".colorize(:cyan)
        puts """"
      end
    end
  end
end",false
blueprint_list_action.rb,/lib/ComputerTools/actions/blueprint/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class BlueprintListAction < Sublayer::Actions::Base
      def initialize(format: :table, interactive: false, limit: 50)
        @format = format
        @interactive = interactive
        @limit = limit
        @db = ComputerTools::Wrappers::BlueprintDatabase.new
      end

      def call
        puts ""üìã Fetching blueprints..."".colorize(:blue)
        
        blueprints = @db.list_blueprints(limit: @limit)
        
        if blueprints.empty?
          puts ""üì≠ No blueprints found"".colorize(:yellow)
          return true
        end

        puts ""‚úÖ Found #{blueprints.length} blueprints"".colorize(:green)
        
        if @interactive && tty_prompt_available?
          interactive_blueprint_browser(blueprints)
        else
          display_blueprints(blueprints)
        end
        
        true
      rescue => e
        puts ""‚ùå Error listing blueprints: #{e.message}"".colorize(:red)
        puts e.backtrace.first(3).join(""\n"") if ENV['DEBUG']
        false
      end

      private

      def display_blueprints(blueprints)
        case @format
        when :table
          display_table(blueprints)
        when :summary
          display_summary(blueprints)
        when :json
          puts JSON.pretty_generate(blueprints)
        else
          display_table(blueprints)
        end
      end

      def display_table(blueprints)
        puts ""\n"" + ""="" * 120
        printf ""%-5s %-30s %-50s %-25s\n"", ""ID"", ""Name"", ""Description"", ""Categories""
        puts ""="" * 120
        
        blueprints.each do |blueprint|
          name = truncate_text(blueprint[:name] || 'Untitled', 28)
          description = truncate_text(blueprint[:description] || 'No description', 48)
          categories = get_category_text(blueprint[:categories])
          
          printf ""%-5s %-30s %-50s %-25s\n"", 
                 blueprint[:id], 
                 name, 
                 description, 
                 categories
        end
        puts ""="" * 120
        puts """"
      end

      def display_summary(blueprints)
        puts ""\nüìä Blueprint Collection Summary"".colorize(:blue)
        puts ""="" * 50
        puts ""Total blueprints: #{blueprints.length}""
        
        # Category analysis
        all_categories = blueprints.flat_map { |b| b[:categories].map { |c| c[:name] } }
        category_counts = all_categories.each_with_object(Hash.new(0)) { |cat, hash| hash[cat] += 1 }
        
        if category_counts.any?
          puts ""\nTop categories:""
          category_counts.sort_by { |_, count| -count }.first(5).each do |category, count|
            puts ""  #{category}: #{count} blueprints""
          end
        end
        
        # Recent blueprints
        puts ""\nMost recent blueprints:""
        blueprints.first(5).each do |blueprint|
          puts ""  #{blueprint[:id]}: #{blueprint[:name]}""
        end
        puts """"
      end

      def interactive_blueprint_browser(blueprints)
        return unless tty_prompt_available?
        
        prompt = TTY::Prompt.new
        
        loop do
          puts ""\n"" + ""="" * 80
          puts ""üìö Blueprint Browser"".colorize(:blue)
          puts ""Found #{blueprints.length} blueprints""
          puts ""="" * 80
          
          # Prepare choices for the prompt
          choices = prepare_blueprint_choices(blueprints)
          
          # Add action options
          choices << { name: ""üîç Search blueprints"".colorize(:blue), value: :search }
          choices << { name: ""üìä Show summary"".colorize(:yellow), value: :summary }
          choices << { name: ""‚ûï Submit new blueprint"".colorize(:green), value: :submit }
          choices << { name: ""üö™ Exit"".colorize(:red), value: :exit }
          
          selected = prompt.select(""Select a blueprint or action:"", choices, per_page: 15)
          
          case selected
          when Hash
            # A blueprint was selected
            handle_selected_blueprint(selected, prompt)
          when :search
            handle_search_action(prompt)
          when :summary
            display_summary(blueprints)
            prompt.keypress(""Press any key to continue..."")
          when :submit
            handle_submit_action(prompt)
          when :exit
            puts ""üëã Goodbye!"".colorize(:green)
            break
          end
        end
      end

      def prepare_blueprint_choices(blueprints)
        blueprints.map do |blueprint|
          name = truncate_text(blueprint[:name] || 'Untitled', 40)
          description = truncate_text(blueprint[:description] || 'No description', 50)
          categories = get_category_text(blueprint[:categories], 20)
          
          display_text = ""#{name.ljust(42)} | #{description.ljust(52)} | #{categories}""
          
          {
            name: display_text,
            value: blueprint
          }
        end
      end

      def handle_selected_blueprint(blueprint, prompt)
        actions = [
          { name: ""üëÅÔ∏è  View details"", value: :view },
          { name: ""‚úèÔ∏è  Edit blueprint"", value: :edit },
          { name: ""üíæ Export code"", value: :export },
          { name: ""üîç View with AI analysis"", value: :analyze },
          { name: ""üìã Copy ID"", value: :copy_id },
          { name: ""‚Ü©Ô∏è  Back to list"", value: :back }
        ]
        
        action = prompt.select(""What would you like to do with '#{blueprint[:name]}'?"", actions)
        
        case action
        when :view
          ComputerTools::Actions::BlueprintViewAction.new(
            id: blueprint[:id],
            format: :detailed
          ).call
          prompt.keypress(""Press any key to continue..."")
        when :edit
          ComputerTools::Actions::BlueprintEditAction.new(
            id: blueprint[:id]
          ).call
          prompt.keypress(""Press any key to continue..."")
        when :export
          filename = prompt.ask(""üíæ Export filename:"", default: generate_export_filename(blueprint))
          ComputerTools::Actions::BlueprintExportAction.new(
            id: blueprint[:id],
            output_path: filename
          ).call
          prompt.keypress(""Press any key to continue..."")
        when :analyze
          ComputerTools::Actions::BlueprintViewAction.new(
            id: blueprint[:id],
            format: :detailed,
            with_suggestions: true
          ).call
          prompt.keypress(""Press any key to continue..."")
        when :copy_id
          puts ""üìã Blueprint ID: #{blueprint[:id]}"".colorize(:green)
          # Try to copy to clipboard if available
          copy_to_clipboard(blueprint[:id].to_s)
          prompt.keypress(""Press any key to continue..."")
        when :back
          # Return to blueprint list
          return
        end
      end

      def handle_search_action(prompt)
        query = prompt.ask(""üîç Enter search query:"", required: true)
        
        ComputerTools::Actions::BlueprintSearchAction.new(
          query: query,
          limit: 10
        ).call
        
        prompt.keypress(""Press any key to continue..."")
      end

      def handle_submit_action(prompt)
        submit_choice = prompt.select(""Submit from:"", [
          { name: ""üìÅ File"", value: :file },
          { name: ""‚úèÔ∏è  Text input"", value: :text }
        ])
        
        if submit_choice == :file
          file_path = prompt.ask(""üìÅ Enter file path:"")
          if file_path && File.exist?(file_path)
            code = File.read(file_path)
            ComputerTools::Actions::BlueprintSubmitAction.new(code: code).call
          else
            puts ""‚ùå File not found: #{file_path}"".colorize(:red)
          end
        else
          code = prompt.multiline(""‚úèÔ∏è  Enter code (Ctrl+D to finish):"")
          if code && !code.join(""\n"").strip.empty?
            ComputerTools::Actions::BlueprintSubmitAction.new(code: code.join(""\n"")).call
          end
        end
        
        prompt.keypress(""Press any key to continue..."")
      end

      def get_category_text(categories, max_length = 23)
        return 'No categories' if categories.nil? || categories.empty?
        
        category_names = categories.map { |cat| cat[:title] }
        text = category_names.join(', ')
        truncate_text(text, max_length)
      end

      def generate_export_filename(blueprint)
        base_name = (blueprint[:name] || 'blueprint').gsub(/[^a-zA-Z0-9_-]/, '_').downcase
        extension = detect_file_extension(blueprint[:code] || '')
        ""#{base_name}_#{blueprint[:id]}#{extension}""
      end

      def detect_file_extension(code)
        case code
        when /class\s+\w+.*<.*ApplicationRecord/m, /def\s+\w+.*end/m
          '.rb'
        when /function\s+\w+\s*\(/m, /const\s+\w+\s*=/m
          '.js'
        when /def\s+\w+\s*\(/m, /import\s+\w+/m
          '.py'
        when /#include\s*<.*>/m, /int\s+main\s*\(/m
          '.c'
        else
          '.txt'
        end
      end

      def copy_to_clipboard(text)
        # Try different clipboard commands
        commands = [
          ""echo '#{text}' | pbcopy"",           # macOS
          ""echo '#{text}' | xclip -selection clipboard"", # Linux with xclip
          ""echo '#{text}' | xsel -i -b""       # Linux with xsel
        ]
        
        commands.each do |cmd|
          if system(cmd + "" 2>/dev/null"")
            puts ""üìã Copied to clipboard!"".colorize(:green)
            return true
          end
        end
        
        puts ""‚ö†Ô∏è  Could not copy to clipboard (clipboard tool not available)"".colorize(:yellow)
        false
      end

      def truncate_text(text, length)
        return text if text.length <= length
        text[0..length-4] + ""...""
      end

      def tty_prompt_available?
        defined?(TTY::Prompt)
      end
    end
  end
end",false
blueprint_search_action.rb,/lib/ComputerTools/actions/blueprint/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class BlueprintSearchAction < Sublayer::Actions::Base
      def initialize(query:, limit: 10, semantic: true)
        @query = query
        @limit = limit
        @semantic = semantic
        @db = ComputerTools::Wrappers::BlueprintDatabase.new
      end

      def call
        puts ""üîç Searching for: '#{@query}'..."".colorize(:blue)
        
        if @semantic
          results = semantic_search
        else
          results = text_search
        end
        
        if results.empty?
          puts ""üì≠ No blueprints found matching '#{@query}'"".colorize(:yellow)
          return true
        end

        puts ""‚úÖ Found #{results.length} matching blueprints"".colorize(:green)
        display_search_results(results)
        
        true
      rescue => e
        puts ""‚ùå Error searching blueprints: #{e.message}"".colorize(:red)
        puts e.backtrace.first(3).join(""\n"") if ENV['DEBUG']
        false
      end

      private

      def semantic_search
        # Use vector similarity search for semantic matching
        @db.search_blueprints(query: @query, limit: @limit)
      end

      def text_search
        # Fallback to simple text search in name, description, and code
        blueprints = @db.list_blueprints(limit: 1000) # Get more for filtering
        
        query_words = @query.downcase.split(/\s+/)
        
        results = blueprints.select do |blueprint|
          searchable_text = [
            blueprint[:name],
            blueprint[:description],
            blueprint[:code],
            blueprint[:categories].map { |c| c[:title] }.join(' ')
          ].compact.join(' ').downcase
          
          # Check if all query words are present
          query_words.all? { |word| searchable_text.include?(word) }
        end
        
        # Sort by relevance (simple scoring)
        results.sort_by do |blueprint|
          score = calculate_text_relevance(blueprint, query_words)
          -score # Negative for descending order
        end.first(@limit)
      end

      def calculate_text_relevance(blueprint, query_words)
        score = 0
        
        # Higher weight for matches in name and description
        name_text = (blueprint[:name] || '').downcase
        desc_text = (blueprint[:description] || '').downcase
        code_text = blueprint[:code].downcase
        
        query_words.each do |word|
          score += 10 if name_text.include?(word)
          score += 5 if desc_text.include?(word)
          score += 1 if code_text.include?(word)
        end
        
        score
      end

      def display_search_results(results)
        puts ""\n"" + ""="" * 120
        puts ""üîç Search Results for: '#{@query}'"".colorize(:blue)
        puts ""="" * 120
        
        if @semantic && results.first && results.first.key?(:distance)
          # Show similarity scores for semantic search
          printf ""%-5s %-30s %-40s %-20s %-10s\n"", ""ID"", ""Name"", ""Description"", ""Categories"", ""Score""
          puts ""-"" * 120
          
          results.each do |blueprint|
            name = truncate_text(blueprint[:name] || 'Untitled', 28)
            description = truncate_text(blueprint[:description] || 'No description', 38)
            categories = get_category_text(blueprint[:categories])
            similarity = calculate_similarity_percentage(blueprint[:distance])
            
            printf ""%-5s %-30s %-40s %-20s %-10s\n"", 
                   blueprint[:id], 
                   name, 
                   description, 
                   categories,
                   ""#{similarity}%""
          end
        else
          # Standard display for text search
          printf ""%-5s %-35s %-50s %-25s\n"", ""ID"", ""Name"", ""Description"", ""Categories""
          puts ""-"" * 120
          
          results.each do |blueprint|
            name = truncate_text(blueprint[:name] || 'Untitled', 33)
            description = truncate_text(blueprint[:description] || 'No description', 48)
            categories = get_category_text(blueprint[:categories])
            
            printf ""%-5s %-35s %-50s %-25s\n"", 
                   blueprint[:id], 
                   name, 
                   description, 
                   categories
          end
        end
        
        puts ""="" * 120
        puts """"
        
        # Show usage hints
        show_usage_hints(results)
      end

      def calculate_similarity_percentage(distance)
        # Convert distance to percentage (lower distance = higher similarity)
        # This is a rough approximation - adjust based on your embedding space
        similarity = [100 - (distance * 100), 0].max
        similarity.round(1)
      end

      def get_category_text(categories)
        return 'None' if categories.nil? || categories.empty?
        
        category_names = categories.map { |cat| cat[:title] }
        text = category_names.join(', ')
        truncate_text(text, 23)
      end

      def show_usage_hints(results)
        puts ""üí° Next steps:"".colorize(:cyan)
        puts ""   blueprint view <id>           View full blueprint details""
        puts ""   blueprint view <id> --analyze Get AI analysis and suggestions""
        puts ""   blueprint edit <id>           Edit a blueprint""
        puts ""   blueprint export <id>         Export blueprint code""
        
        if results.any?
          sample_id = results.first[:id]
          puts ""\nüìã Example: blueprint view #{sample_id}"".colorize(:yellow)
        end
        puts """"
      end

      def truncate_text(text, length)
        return text if text.length <= length
        text[0..length-4] + ""...""
      end
    end
  end
end",false
blueprint_submit_action.rb,/lib/ComputerTools/actions/blueprint/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class BlueprintSubmitAction < Sublayer::Actions::Base
      def initialize(code:, name: nil, description: nil, categories: nil, auto_describe: true, auto_categorize: true)
        @code = code
        @name = name
        @description = description
        @categories = categories || []
        @auto_describe = auto_describe
        @auto_categorize = auto_categorize
        @db = ComputerTools::Wrappers::BlueprintDatabase.new
      end

      def call
        puts ""üöÄ Processing blueprint submission..."".colorize(:blue)
        
        # Generate missing metadata using AI
        generate_missing_metadata
        
        # Validate required fields
        unless validate_blueprint_data
          return false
        end

        # Create the blueprint in database
        blueprint = @db.create_blueprint(
          code: @code,
          name: @name,
          description: @description,
          categories: @categories
        )

        if blueprint
          puts ""‚úÖ Blueprint created successfully!"".colorize(:green)
          display_blueprint_summary(blueprint)
          true
        else
          puts ""‚ùå Failed to create blueprint"".colorize(:red)
          false
        end
      rescue => e
        puts ""‚ùå Error submitting blueprint: #{e.message}"".colorize(:red)
        puts e.backtrace.first(3).join(""\n"") if ENV['DEBUG']
        false
      end

      private

      def generate_missing_metadata
        # Generate name if not provided
        if @name.nil? || @name.strip.empty?
          puts ""üìù Generating blueprint name..."".colorize(:yellow)
          @name = ComputerTools::Generators::BlueprintNameGenerator.new(
            code: @code,
            description: @description
          ).generate
          puts ""   Generated name: #{@name}"".colorize(:cyan)
        end

        # Generate description if not provided and auto_describe is enabled
        if (@description.nil? || @description.strip.empty?) && @auto_describe
          puts ""üìñ Generating blueprint description..."".colorize(:yellow)
          @description = ComputerTools::Generators::BlueprintDescriptionGenerator.new(
            code: @code
          ).generate
          puts ""   Generated description: #{truncate_text(@description, 80)}"".colorize(:cyan)
        end

        # Generate categories if not provided and auto_categorize is enabled
        if @categories.empty? && @auto_categorize
          puts ""üè∑Ô∏è  Generating blueprint categories..."".colorize(:yellow)
          @categories = ComputerTools::Generators::BlueprintCategoryGenerator.new(
            code: @code,
            description: @description
          ).generate
          puts ""   Generated categories: #{@categories.join(', ')}"".colorize(:cyan)
        end
      end

      def validate_blueprint_data
        errors = []

        if @code.nil? || @code.strip.empty?
          errors << ""Code cannot be empty""
        end

        if @name.nil? || @name.strip.empty?
          errors << ""Name is required (auto-generation failed)""
        end

        if @description.nil? || @description.strip.empty?
          if @auto_describe
            errors << ""Description generation failed""
          else
            puts ""‚ö†Ô∏è  Warning: No description provided"".colorize(:yellow)
          end
        end

        if errors.any?
          puts ""‚ùå Validation errors:"".colorize(:red)
          errors.each { |error| puts ""   - #{error}"".colorize(:red) }
          return false
        end

        true
      end

      def display_blueprint_summary(blueprint)
        puts ""\n"" + ""="" * 60
        puts ""üìã Blueprint Summary"".colorize(:blue)
        puts ""="" * 60
        puts ""ID: #{blueprint[:id]}""
        puts ""Name: #{blueprint[:name]}""
        puts ""Description: #{blueprint[:description]}""
        
        if blueprint[:categories] && blueprint[:categories].any?
          category_names = blueprint[:categories].map { |cat| cat[:title] }
          puts ""Categories: #{category_names.join(', ')}""
        end
        
        puts ""Code length: #{@code.length} characters""
        puts ""Created: #{blueprint[:created_at]}""
        puts ""="" * 60
        puts """"
      end

      def truncate_text(text, length)
        return text if text.length <= length
        text[0..length-4] + ""...""
      end
    end
  end
end",false
blueprint_view_action.rb,/lib/ComputerTools/actions/blueprint/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class BlueprintViewAction < Sublayer::Actions::Base
      def initialize(id:, format: :detailed, with_suggestions: false)
        @id = id
        @format = format
        @with_suggestions = with_suggestions
        @db = ComputerTools::Wrappers::BlueprintDatabase.new
      end

      def call
        puts ""üîç Fetching blueprint #{@id}..."".colorize(:blue)
        
        blueprint = @db.get_blueprint(@id)
        unless blueprint
          puts ""‚ùå Blueprint #{@id} not found"".colorize(:red)
          return false
        end

        # Generate AI suggestions if requested
        if @with_suggestions
          puts ""ü§ñ Generating AI analysis..."".colorize(:yellow)
          blueprint[:ai_suggestions] = generate_suggestions(blueprint)
        end

        case @format
        when :detailed
          display_detailed(blueprint)
        when :json
          puts JSON.pretty_generate(blueprint)
        when :code_only
          puts blueprint[:code]
        when :summary
          display_summary(blueprint)
        end
        
        true
      rescue => e
        puts ""‚ùå Error viewing blueprint: #{e.message}"".colorize(:red)
        puts e.backtrace.first(3).join(""\n"") if ENV['DEBUG']
        false
      end

      private

      def display_detailed(blueprint)
        content = build_detailed_content(blueprint)
        
        if tty_pager_available?
          TTY::Pager.page(content)
        else
          puts content
        end
      end

      def build_detailed_content(blueprint)
        content = []
        content << ""="" * 80
        content << ""üìã Blueprint Details"".colorize(:blue).to_s
        content << ""="" * 80
        content << ""ID: #{blueprint[:id]}""
        content << ""Name: #{blueprint[:name]}""
        content << ""Created: #{blueprint[:created_at]}""
        content << ""Updated: #{blueprint[:updated_at]}""
        content << """"
        
        # Categories
        if blueprint[:categories] && blueprint[:categories].any?
          category_names = blueprint[:categories].map { |cat| cat[:title] }
          content << ""Categories: #{category_names.join(', ')}""
        else
          content << ""Categories: None""
        end
        content << """"
        
        # Description
        content << ""Description:""
        content << blueprint[:description] || ""No description available""
        content << """"
        
        # AI Suggestions (if available)
        if blueprint[:ai_suggestions]
          content << ""ü§ñ AI Analysis & Suggestions:"".colorize(:cyan).to_s
          content << ""-"" * 40
          
          if blueprint[:ai_suggestions][:improvements]
            content << ""üí° Improvements:"".colorize(:yellow).to_s
            blueprint[:ai_suggestions][:improvements].each do |improvement|
              content << ""  ‚Ä¢ #{improvement}""
            end
            content << """"
          end
          
          if blueprint[:ai_suggestions][:quality_assessment]
            content << ""üìä Quality Assessment:"".colorize(:yellow).to_s
            content << blueprint[:ai_suggestions][:quality_assessment]
            content << """"
          end
        end
        
        # Code
        content << ""-"" * 80
        content << ""üíª Code:"".colorize(:green).to_s
        content << ""-"" * 80
        content << blueprint[:code]
        content << ""="" * 80
        
        content.join(""\n"")
      end

      def display_summary(blueprint)
        puts ""\nüìã Blueprint Summary"".colorize(:blue)
        puts ""="" * 50
        puts ""ID: #{blueprint[:id]}""
        puts ""Name: #{blueprint[:name]}""
        puts ""Description: #{truncate_text(blueprint[:description] || 'No description', 60)}""
        
        if blueprint[:categories] && blueprint[:categories].any?
          category_names = blueprint[:categories].map { |cat| cat[:title] }
          puts ""Categories: #{category_names.join(', ')}""
        end
        
        puts ""Code length: #{blueprint[:code].length} characters""
        puts ""Created: #{blueprint[:created_at]}""
        puts ""="" * 50
        puts """"
      end

      def generate_suggestions(blueprint)
        suggestions = {}
        
        begin
          # Generate improvement suggestions
          improvements = ComputerTools::Generators::BlueprintImprovementGenerator.new(
            code: blueprint[:code],
            description: blueprint[:description]
          ).generate
          
          suggestions[:improvements] = improvements if improvements
          
        rescue => e
          puts ""‚ö†Ô∏è  Could not generate AI suggestions: #{e.message}"".colorize(:yellow)
        end
        
        suggestions
      end

      def truncate_text(text, length)
        return text if text.length <= length
        text[0..length-4] + ""...""
      end

      def tty_pager_available?
        defined?(TTY::Pager)
      end
    end
  end
end",false
deepgram_analyze_action.rb,/lib/ComputerTools/actions/deepgram/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class DeepgramAnalyzeAction < Sublayer::Actions::Base
      def initialize(json_file:, interactive: false, console_output: false)
        @json_file = json_file
        @interactive = interactive
        @console_output = console_output
        @prompt = TTY::Prompt.new if @interactive
      end

      def call
        puts ""üîç Analyzing Deepgram segments..."".colorize(:blue)

        begin
          analyzer = ComputerTools::Wrappers::DeepgramAnalyzer.new(@json_file)

          # Display analysis overview
          display_analysis_overview(analyzer)

          if @interactive
            handle_interactive_analysis(analyzer)
          else
            handle_automatic_analysis(analyzer)
          end

          puts ""‚úÖ Analysis completed successfully!"".colorize(:green)
          true
        rescue StandardError => e
          puts ""‚ùå Error analyzing segments: #{e.message}"".colorize(:red)
          puts e.backtrace.first(3).join(""\n"") if ENV['DEBUG']
          false
        end
      end

      private

      def display_analysis_overview(analyzer)
        stats = analyzer.summary_stats

        puts ""\nüìä Analysis Overview:"".colorize(:blue)
        puts ""   ‚Ä¢ Total Segments: #{stats[:total_segments]}""
        puts ""   ‚Ä¢ Available Fields: #{stats[:available_fields]}""
        puts ""   ‚Ä¢ Fields with Data: #{stats[:fields_with_data]}""

        puts ""   ‚Ä¢ AI Analysis Present: #{analyzer.has_ai_analysis? ? '‚úÖ' : '‚ùå'}""
        puts ""   ‚Ä¢ Software Detection: #{analyzer.has_software_detection? ? '‚úÖ' : '‚ùå'}""

        puts ""   ‚Ä¢ Topics: #{analyzer.get_all_topics.join(', ')}"" if analyzer.get_all_topics.any?

        puts ""   ‚Ä¢ Software Detected: #{analyzer.get_all_software.join(', ')}"" if analyzer.get_all_software.any?

        puts """"
      end

      def handle_interactive_analysis(analyzer)
        loop do
          choice = @prompt.select(
            ""What would you like to do?"", {
              ""View specific fields"" => :view_fields,
              ""Filter by topic""      => :filter_topic,
              ""Filter by software""   => :filter_software,
              ""Export analysis""      => :export,
              ""Exit""                 => :exit
            }
          )

          case choice
          when :view_fields
            handle_field_selection(analyzer)
          when :filter_topic
            handle_topic_filter(analyzer)
          when :filter_software
            handle_software_filter(analyzer)
          when :export
            handle_export(analyzer)
          when :exit
            break
          end
        end
      end

      def handle_automatic_analysis(analyzer)
        # Show all available fields automatically
        available_fields = analyzer.get_field_options

        if available_fields.any?
          puts ""üìã Displaying all available fields:"".colorize(:blue)
          results = analyzer.extract_fields(available_fields)
          display_results(results)
        else
          puts ""‚ö†Ô∏è  No recognizable fields found in the segments"".colorize(:yellow)
        end
      end

      def handle_field_selection(analyzer)
        available_fields = analyzer.get_field_options

        if available_fields.empty?
          puts ""‚ùå No fields with data available"".colorize(:red)
          return
        end

        selected_fields = @prompt.multi_select(
          ""Select fields to display:"",
          available_fields,
          default: available_fields.first(3)
        )

        return unless selected_fields.any?

        results = analyzer.extract_fields(selected_fields)
        display_results(results)
      end

      def handle_topic_filter(analyzer)
        topics = analyzer.get_all_topics

        if topics.empty?
          puts ""‚ùå No topics found in segments"".colorize(:red)
          return
        end

        selected_topic = @prompt.select(""Select topic to filter by:"", topics)
        filtered_segments = analyzer.filter_by_topic(selected_topic)

        puts ""üìã Segments for topic '#{selected_topic}':"".colorize(:blue)
        display_segments(filtered_segments)
      end

      def handle_software_filter(analyzer)
        software_list = analyzer.get_all_software

        if software_list.empty?
          puts ""‚ùå No software detections found"".colorize(:red)
          return
        end

        selected_software = @prompt.select(""Select software to filter by:"", software_list)
        filtered_segments = analyzer.filter_by_software(selected_software)

        puts ""üìã Segments with '#{selected_software}':"".colorize(:blue)
        display_segments(filtered_segments)
      end

      def handle_export(analyzer)
        format = @prompt.select(
          ""Export format:"", {
            ""JSON"" => :json,
            ""Markdown"" => :markdown,
            ""CSV""      => :csv
          }
        )

        output_file = generate_export_filename(format)
        export_analysis(analyzer, format, output_file)
        puts ""üìÑ Analysis exported to: #{output_file}"".colorize(:cyan)
      end

      def display_results(results)
        return if results.empty?

        results.each_with_index do |segment_data, index|
          puts ""\n=== Segment #{index + 1} ==="".colorize(:cyan)
          segment_data.each do |field_name, value|
            puts ""#{field_name}: #{value}""
          end
        end
        puts """"
      end

      def display_segments(segments)
        segments.each_with_index do |segment, index|
          puts ""\n--- Segment #{index + 1} ---""
          puts ""Transcript: #{segment['transcript']}"" if segment['transcript']
          puts ""Topic: #{segment['topic']}"" if segment['topic']
          puts ""Analysis: #{segment['gemini_analysis']}"" if segment['gemini_analysis']
          puts ""Software: #{segment['software_detected']}"" if segment['software_detected']
        end
        puts """"
      end

      def generate_export_filename(format)
        base_name = File.basename(@json_file, "".*"")
        extension = case format
                    when :json
                      '_analysis.json'
                    when :markdown
                      '_analysis.md'
                    when :csv
                      '_analysis.csv'
                    end

        File.join(File.dirname(@json_file), ""#{base_name}#{extension}"")
      end

      def export_analysis(analyzer, format, output_file)
        case format
        when :json
          content = {
            summary: analyzer.summary_stats,
            segments: analyzer.segments,
            topics: analyzer.get_all_topics,
            software: analyzer.get_all_software
          }.to_json
        when :markdown
          content = generate_markdown_export(analyzer)
        when :csv
          content = generate_csv_export(analyzer)
        end

        File.write(output_file, content)
      end

      def generate_markdown_export(analyzer)
        content = [""# Deepgram Segment Analysis\n""]

        content << ""## Summary\n""
        stats = analyzer.summary_stats
        content << ""- Total Segments: #{stats[:total_segments]}\n""
        content << ""- Available Fields: #{stats[:available_fields]}\n""
        content << ""- AI Analysis: #{analyzer.has_ai_analysis? ? 'Yes' : 'No'}\n""
        content << ""- Software Detection: #{analyzer.has_software_detection? ? 'Yes' : 'No'}\n\n""

        content << ""## Segments\n""
        analyzer.segments.each_with_index do |segment, index|
          content << ""### Segment #{index + 1}\n""
          segment.each do |key, value|
            next if value.nil? || value.to_s.strip.empty?

            content << ""- **#{key.tr('_', ' ').split.map(&:capitalize).join(' ')}**: #{value}\n""
          end
          content << ""\n""
        end

        content.join
      end

      def generate_csv_export(analyzer)
        require 'csv'

        CSV.generate do |csv|
          # Header row
          headers = analyzer.segments.first&.keys || []
          csv << headers

          # Data rows
          analyzer.segments.each do |segment|
            row = headers.map { |header| segment[header] }
            csv << row
          end
        end
      end
    end
  end
end",false
deepgram_config_action.rb,/lib/ComputerTools/actions/deepgram/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class DeepgramConfigAction < Sublayer::Actions::Base
      def initialize(subcommand:)
        @subcommand = subcommand
        @config_file = File.join(__dir__, '..', 'config', 'deepgram.yml')
      end

      def call
        case @subcommand
        when 'show'
          show_config
        when 'setup'
          setup_config
        when 'edit'
          edit_config
        when 'reset'
          reset_config
        else
          puts ""‚ùå Unknown config subcommand: #{@subcommand}"".colorize(:red)
          show_help
          false
        end
      end

      private

      def show_config
        puts ""üîß Deepgram Configuration"".colorize(:blue)
        puts ""="" * 50

        if File.exist?(@config_file)
          config = YAML.load_file(@config_file)
          display_config(config)
        else
          puts ""‚ö†Ô∏è  No configuration file found"".colorize(:yellow)
          puts ""Run 'deepgram config setup' to create one""
        end

        puts ""\nConfiguration file: #{@config_file}""
        true
      end

      def setup_config
        puts ""üöÄ Setting up Deepgram configuration..."".colorize(:blue)

        # Ensure config directory exists
        FileUtils.mkdir_p(File.dirname(@config_file))

        # Create default configuration
        default_config = {
          'output' => {
            'default_format' => 'markdown',
            'auto_timestamp' => true,
            'include_confidence' => true
          },
          'ai' => {
            'provider' => 'gemini',
            'model' => 'gemini-1.5-flash-latest',
            'enable_insights' => true,
            'enable_summaries' => true
          },
          'formats' => {
            'srt' => {
              'include_milliseconds' => true,
              'line_length' => 42
            },
            'markdown' => {
              'include_stats' => true,
              'include_metadata' => true
            }
          }
        }

        File.write(@config_file, default_config.to_yaml)

        puts ""‚úÖ Configuration created successfully!"".colorize(:green)
        puts ""üìÑ Config file: #{@config_file}""

        # Show the created configuration
        display_config(default_config)
        true
      end

      def edit_config
        unless File.exist?(@config_file)
          puts ""‚ùå Configuration file not found"".colorize(:red)
          puts ""Run 'deepgram config setup' first""
          return false
        end

        editor = ENV['EDITOR'] || ENV['VISUAL'] || 'nano'
        system(""#{editor} #{@config_file}"")

        puts ""‚úÖ Configuration updated"".colorize(:green)
        true
      end

      def reset_config
        if File.exist?(@config_file)
          File.delete(@config_file)
          puts ""‚úÖ Configuration reset successfully"".colorize(:green)
        else
          puts ""‚ö†Ô∏è  No configuration file to reset"".colorize(:yellow)
        end

        puts ""Run 'deepgram config setup' to create a new configuration""
        true
      end

      def display_config(config)
        puts ""\nüìã Current Configuration:"".colorize(:cyan)

        puts ""\nüéØ Output Settings:""
        output = config['output'] || {}
        puts ""   ‚Ä¢ Default Format: #{output['default_format'] || 'markdown'}""
        puts ""   ‚Ä¢ Auto Timestamp: #{output['auto_timestamp'] || true}""
        puts ""   ‚Ä¢ Include Confidence: #{output['include_confidence'] || true}""

        puts ""\nü§ñ AI Settings:""
        ai = config['ai'] || {}
        puts ""   ‚Ä¢ Provider: #{ai['provider'] || 'gemini'}""
        puts ""   ‚Ä¢ Model: #{ai['model'] || 'gemini-1.5-flash-latest'}""
        puts ""   ‚Ä¢ Enable Insights: #{ai['enable_insights'] || true}""
        puts ""   ‚Ä¢ Enable Summaries: #{ai['enable_summaries'] || true}""

        puts ""\nüìÑ Format Settings:""
        formats = config['formats'] || {}

        if formats['srt']
          puts ""   SRT:""
          puts ""     ‚Ä¢ Include Milliseconds: #{formats['srt']['include_milliseconds'] || true}""
          puts ""     ‚Ä¢ Line Length: #{formats['srt']['line_length'] || 42}""
        end

        return unless formats['markdown']

        puts ""   Markdown:""
        puts ""     ‚Ä¢ Include Stats: #{formats['markdown']['include_stats'] || true}""
        puts ""     ‚Ä¢ Include Metadata: #{formats['markdown']['include_metadata'] || true}""
      end

      def show_help
        puts <<~HELP
          Configuration Commands:

          deepgram config show           Show current configuration
          deepgram config setup          Create default configuration
          deepgram config edit           Edit configuration file
          deepgram config reset          Reset configuration to defaults
        HELP
      end
    end
  end
end",false
deepgram_convert_action.rb,/lib/ComputerTools/actions/deepgram/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class DeepgramConvertAction < Sublayer::Actions::Base
      SUPPORTED_FORMATS = %w[srt markdown md json summary].freeze

      def initialize(json_file:, format:, output_file: nil, console_output: false)
        @json_file = json_file
        @format = format.downcase
        @output_file = output_file
        @console_output = console_output
      end

      def call
        puts ""üîÑ Converting Deepgram output to #{@format.upcase}..."".colorize(:blue)

        unless SUPPORTED_FORMATS.include?(@format)
          puts ""‚ùå Unsupported format: #{@format}"".colorize(:red)
          puts ""Supported formats: #{SUPPORTED_FORMATS.join(', ')}""
          return false
        end

        begin
          parser = ComputerTools::Wrappers::DeepgramParser.new(@json_file)
          formatter = ComputerTools::Wrappers::DeepgramFormatter.new(parser)

          # Generate content in requested format
          content = generate_content(formatter)

          # Handle output
          handle_output(content)

          puts ""‚úÖ Conversion completed successfully!"".colorize(:green)
          true
        rescue StandardError => e
          puts ""‚ùå Error converting file: #{e.message}"".colorize(:red)
          puts e.backtrace.first(3).join(""\n"") if ENV['DEBUG']
          false
        end
      end

      private

      def generate_content(formatter)
        case @format
        when 'srt'
          formatter.to_srt
        when 'markdown', 'md'
          formatter.to_markdown
        when 'json'
          formatter.to_json
        when 'summary'
          formatter.to_summary
        else
          raise ""Unsupported format: #{@format}""
        end
      end

      def handle_output(content)
        if @console_output
          puts ""\n"" + (""="" * 60)
          puts content
        else
          output_file = determine_output_file
          File.write(output_file, content)
          puts ""üìÑ Converted file saved to: #{output_file}"".colorize(:cyan)

          # Show format-specific success message
          display_format_specific_message(output_file)
        end
      end

      def determine_output_file
        return @output_file if @output_file

        base_name = File.basename(@json_file, "".*"")
        extension = case @format
                    when 'srt'
                      '.srt'
                    when 'markdown', 'md'
                      '.md'
                    when 'json'
                      '_converted.json'
                    when 'summary'
                      '_summary.txt'
                    end

        File.join(File.dirname(@json_file), ""#{base_name}#{extension}"")
      end

      def display_format_specific_message(_output_file)
        case @format
        when 'srt'
          puts ""üé¨ SRT subtitle file ready for video players"".colorize(:green)
        when 'markdown', 'md'
          puts ""üìù Markdown file ready for documentation"".colorize(:green)
        when 'json'
          puts ""üìä JSON file ready for further processing"".colorize(:green)
        when 'summary'
          puts ""üìã Summary file ready for quick review"".colorize(:green)
        end
      end
    end
  end
end",false
deepgram_parse_action.rb,/lib/ComputerTools/actions/deepgram/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class DeepgramParseAction < Sublayer::Actions::Base
      def initialize(json_file:, output_format: 'markdown', output_file: nil, console_output: false)
        @json_file = json_file
        @output_format = output_format.downcase
        @output_file = output_file
        @console_output = console_output
      end

      def call
        puts ""üéôÔ∏è  Parsing Deepgram output..."".colorize(:blue)

        begin
          parser = ComputerTools::Wrappers::DeepgramParser.new(@json_file)
          formatter = ComputerTools::Wrappers::DeepgramFormatter.new(parser)

          # Display summary statistics
          display_summary(parser.summary_stats)

          # Generate output content
          content = generate_content(formatter)

          # Output the content
          handle_output(content)

          puts ""‚úÖ Parsing completed successfully!"".colorize(:green)
          true
        rescue StandardError => e
          puts ""‚ùå Error parsing Deepgram file: #{e.message}"".colorize(:red)
          puts e.backtrace.first(3).join(""\n"") if ENV['DEBUG']
          false
        end
      end

      private

      def generate_content(formatter)
        case @output_format
        when 'markdown', 'md'
          formatter.to_markdown
        when 'srt'
          formatter.to_srt
        when 'json'
          formatter.to_json
        when 'summary'
          formatter.to_summary
        else
          puts ""‚ö†Ô∏è  Unknown format '#{@output_format}', defaulting to markdown"".colorize(:yellow)
          formatter.to_markdown
        end
      end

      def handle_output(content)
        if @console_output
          puts ""\n"" + (""="" * 60)
          puts content
        else
          output_file = determine_output_file
          File.write(output_file, content)
          puts ""üìÑ Output written to: #{output_file}"".colorize(:cyan)
        end
      end

      def determine_output_file
        return @output_file if @output_file

        base_name = File.basename(@json_file, "".*"")
        extension = case @output_format
                    when 'srt'
                      '.srt'
                    when 'json'
                      '_parsed.json'
                    when 'summary'
                      '_summary.txt'
                    else
                      '_analysis.md'
                    end

        File.join(File.dirname(@json_file), ""#{base_name}#{extension}"")
      end

      def display_summary(stats)
        puts ""\nüìä Content Overview:"".colorize(:blue)
        puts ""   ‚Ä¢ Total Words: #{stats[:total_words]}""
        puts ""   ‚Ä¢ Total Sentences: #{stats[:total_sentences]}""
        puts ""   ‚Ä¢ Total Paragraphs: #{stats[:total_paragraphs]}""
        puts ""   ‚Ä¢ Topics Identified: #{stats[:total_topics]}""
        puts ""   ‚Ä¢ Intents Detected: #{stats[:total_intents]}""
        puts ""   ‚Ä¢ Transcript Length: #{stats[:transcript_length]} characters""
        puts """"
      end
    end
  end
end",false
example_action.rb,/lib/ComputerTools/actions/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class ExampleAction < Sublayer::Actions::Base
      def initialize(input:)
        @input = input
      end

      def call
        puts ""Performing action with input: #{@input}""
      end
    end
  end
end",false
file_discovery_action.rb,/lib/ComputerTools/actions/file_activity/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class FileDiscoveryAction < Sublayer::Actions::Base
      def initialize(directory:, time_range:, config:)
        @directory = directory
        @time_range = time_range
        @config = config
      end

      def call
        unless TTY::Which.exist?('fd')
          puts ""‚ùå 'fd' command not found. Please install fd for file search functionality."".colorize(:red)
          return []
        end

        search_dir = @directory == '.' ? home_dir : @directory

        cmd = ""fd --type f --changed-within #{@time_range} . \""#{search_dir}\""""
        files_output = `#{cmd}`

        files = files_output.split(""\n"").filter_map do |file|
          next if file.strip.empty?

          begin
            process_file(file, search_dir)
          rescue StandardError => e
            puts ""‚ö†Ô∏è  Warning: Could not process file #{file}: #{e.message}"".colorize(:yellow)
            next
          end
        end

        puts ""üìÅ Found #{files.length} recently modified files"".colorize(:green)
        files
      rescue StandardError => e
        puts ""‚ùå Error discovering files: #{e.message}"".colorize(:red)
        puts ""   File: #{e.backtrace.first}"" if e.backtrace&.first
        puts ""   Full backtrace:"" if ENV['DEBUG']
        puts e.backtrace.first(3).join(""\n   "") if ENV['DEBUG'] && e.backtrace
        []
      end

      private

      def process_file(file, search_dir)
        stat = File.stat(file)
        relative_path = file.gsub(""#{search_dir}/"", '')

        {
          path: relative_path,
          full_path: file,
          modified_time: stat.mtime,
          size: stat.size,
          tracking_method: determine_tracking_method(file)
        }
      end

      def determine_tracking_method(file_path)
        # Check if file is in a git repository
        dir = File.dirname(file_path)
        while dir != '/' && dir != home_dir
          return :git if File.directory?(File.join(dir, '.git'))

          dir = File.dirname(dir)
        end

        # Check if file is tracked by yadm
        return :yadm if yadm_tracked?(file_path)

        :none
      end

      def yadm_tracked?(file_path)
        return false unless TTY::Which.exist?('yadm')

        cmd = ""yadm list -a""
        output = `#{cmd} 2>/dev/null`
        return false unless $?.success?

        tracked_files = output.split(""\n"")
        relative_path = file_path.gsub(""#{home_dir}/"", '')
        tracked_files.include?(relative_path)
      end

      def home_dir
        @config.fetch('paths', 'home_dir')
      end
    end
  end
end",false
git_analysis_action.rb,/lib/ComputerTools/actions/file_activity/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class GitAnalysisAction < Sublayer::Actions::Base
      def initialize(files:, config:)
        @files = files
        @config = config
      end

      def call
        return [] if @files.empty?

        data = []
        @git_wrapper = ComputerTools::Wrappers::GitWrapper.new

        @files.each do |file_info|
          file_data = analyze_git_file(file_info)
          data << file_data if file_data
        rescue StandardError => e
          puts ""‚ö†Ô∏è  Warning: Could not analyze Git file #{file_info[:path]}: #{e.message}"".colorize(:yellow)
        end

        data
      rescue StandardError => e
        puts ""‚ùå Error analyzing Git files: #{e.message}"".colorize(:red)
        puts ""   File: #{e.backtrace.first}"" if e.backtrace&.first
        puts ""   Full backtrace:"" if ENV['DEBUG']
        puts e.backtrace.first(3).join(""\n   "") if ENV['DEBUG'] && e.backtrace
        []
      end

      private

      def analyze_git_file(file_info)
        repo_path = find_git_repo(file_info[:full_path])
        return nil unless repo_path

        git = @git_wrapper.open_repository(repo_path)
        return nil unless git

        relative_to_repo = file_info[:full_path].gsub(""#{repo_path}/"", '')

        status_info = @git_wrapper.get_file_status(git, relative_to_repo)
        diff_info = @git_wrapper.get_file_diff(git, relative_to_repo)

        create_file_data(file_info, 'Git', status_info, diff_info)
      end

      def find_git_repo(file_path)
        dir = File.dirname(file_path)
        while dir != '/'
          return dir if File.directory?(File.join(dir, '.git'))

          dir = File.dirname(dir)
        end
        nil
      end

      def create_file_data(file_info, tracking, status_info, diff_info)
        {
          file: file_info[:path],
          modified: file_info[:modified_time].strftime(time_format),
          modified_time: file_info[:modified_time],
          size: format_size(file_info[:size]),
          tracking: tracking,
          git_status: status_info[:raw_status] || '--',
          index: status_info[:index] || 'Clean',
          worktree: status_info[:worktree] || 'Clean',
          additions: diff_info[:additions] || 0,
          deletions: diff_info[:deletions] || 0,
          chunks: diff_info[:chunks] || 0
        }
      end

      def time_format
        @config.fetch('display', 'time_format')
      end

      def format_size(bytes)
        return 'N/A' unless bytes.is_a?(Numeric)

        units = ['B', 'KB', 'MB', 'GB']
        size = bytes.to_f
        unit_index = 0

        while size >= 1024 && unit_index < units.length - 1
          size /= 1024.0
          unit_index += 1
        end

        if unit_index == 0
          ""#{size.to_i}#{units[unit_index]}""
        else
          ""#{size.round(1)}#{units[unit_index]}""
        end
      end
    end
  end
end",false
latest_changes_action.rb,/lib/ComputerTools/actions/file_activity/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class LatestChangesAction < Sublayer::Actions::Base
      def initialize(directory:, time_range: '24h', format: 'table', interactive: false)
        @directory = File.expand_path(directory)
        @time_range = time_range
        @format = format.to_sym
        @interactive = interactive
        @configuration = ComputerTools::Configuration.new
        @config = @configuration
      end

      def call
        puts ""üîç Starting file analysis..."".colorize(:blue)
        puts ""üìÅ Directory: #{@directory == File.expand_path('.') ? '.' : @directory}"".colorize(:cyan)
        puts ""‚è∞ Time range: #{@time_range}"".colorize(:cyan)

        # Step 1: Discover recent files
        recent_files = discover_recent_files
        return handle_no_files if recent_files.empty?

        # Step 2: Analyze files by tracking method
        all_data = analyze_files_by_tracking_method(recent_files)
        return handle_no_data if all_data.empty?

        # Step 3: Generate and display report
        generate_report(all_data)

        puts ""‚úÖ Analysis completed successfully!"".colorize(:green)
        true
      rescue StandardError => e
        puts ""‚ùå Error during analysis: #{e.message}"".colorize(:red)
        puts ""   File: #{e.backtrace.first}"" if e.backtrace&.first
        puts ""   Full backtrace:"" if ENV['DEBUG']
        puts e.backtrace.first(5).join(""\n   "") if ENV['DEBUG'] && e.backtrace
        false
      end

      private

      def discover_recent_files
        puts ""üîé Discovering recent files..."".colorize(:yellow)

        FileDiscoveryAction.new(
          directory: @directory,
          time_range: @time_range,
          config: @config
        ).call
      end

      def analyze_files_by_tracking_method(recent_files)
        puts ""üìä Analyzing files by tracking method..."".colorize(:yellow)

        # Group files by tracking method
        git_files = recent_files.select { |f| f[:tracking_method] == :git }
        yadm_files = recent_files.select { |f| f[:tracking_method] == :yadm }
        untracked_files = recent_files.select { |f| f[:tracking_method] == :none }

        all_data = []

        # Process Git files
        unless git_files.empty?
          puts ""  üìù Processing #{git_files.length} Git-tracked files..."".colorize(:blue)
          git_data = GitAnalysisAction.new(
            files: git_files,
            config: @config
          ).call
          all_data.concat(git_data) if git_data
        end

        # Process YADM files
        unless yadm_files.empty?
          puts ""  üè† Processing #{yadm_files.length} YADM-tracked files..."".colorize(:blue)
          yadm_data = YadmAnalysisAction.new(
            files: yadm_files,
            config: @config
          ).call
          all_data.concat(yadm_data) if yadm_data
        end

        # Process untracked files
        unless untracked_files.empty?
          puts ""  üì¶ Processing #{untracked_files.length} untracked files..."".colorize(:blue)
          restic_data = ResticAnalysisAction.new(
            files: untracked_files,
            config: @config
          ).call
          all_data.concat(restic_data) if restic_data
        end

        all_data
      end

      def generate_report(data)
        puts ""üìã Generating activity report..."".colorize(:yellow)

        ComputerTools::Generators::FileActivityReportGenerator.new(
          data: data,
          format: @format,
          interactive: @interactive,
          time_range: @time_range,
          config: @config
        ).call
      end

      def handle_no_files
        puts ""‚ÑπÔ∏è  No files modified in the last #{@time_range}"".colorize(:cyan)
        true
      end

      def handle_no_data
        puts ""‚ÑπÔ∏è  No analyzable file data found"".colorize(:cyan)
        true
      end
    end
  end
end",false
restic_analysis_action.rb,/lib/ComputerTools/actions/file_activity/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class ResticAnalysisAction < Sublayer::Actions::Base
      def initialize(files:, config:)
        @files = files
        @config = config
        @restic_wrapper = ComputerTools::Wrappers::ResticWrapper.new(config)
      end

      def call
        return [] if @files.empty?

        unless TTY::Which.exist?('restic')
          puts ""‚ö†Ô∏è  Warning: 'restic' not found. Skipping backup comparison."".colorize(:yellow)
          return add_untracked_files_without_diff
        end

        data = []

        # Check if restic is already mounted or attempt to mount
        unless @restic_wrapper.ensure_mounted
          puts ""‚ö†Ô∏è  Warning: Could not mount Restic backup. Analyzing files without comparison."".colorize(:yellow)
          return add_untracked_files_without_diff
        end

        snapshot_path = @restic_wrapper.snapshot_path
        unless File.directory?(snapshot_path)
          puts ""‚ö†Ô∏è  Warning: Latest snapshot not found at #{snapshot_path}"".colorize(:yellow)
          return add_untracked_files_without_diff
        end

        @files.each do |file_info|
          file_data = analyze_untracked_file(file_info, snapshot_path)
          data << file_data if file_data
        rescue StandardError => e
          puts ""‚ö†Ô∏è  Warning: Could not analyze file #{file_info[:path]}: #{e.message}"".colorize(:yellow)
        end

        data
      rescue StandardError => e
        puts ""‚ùå Error analyzing untracked files: #{e.message}"".colorize(:red)
        add_untracked_files_without_diff
      end

      private

      def analyze_untracked_file(file_info, snapshot_path)
        snapshot_file = File.join(snapshot_path, file_info[:path])

        if File.exist?(snapshot_file)
          # Compare with snapshot
          diff_result = @restic_wrapper.compare_with_snapshot(file_info[:full_path], snapshot_file)

          status_info = {
            raw_status: diff_result[:changed] ? 'M ' : '--',
            index: 'N/A',
            worktree: diff_result[:changed] ? 'Modified' : 'Unchanged'
          }

          create_file_data(file_info, 'Restic', status_info, diff_result)
        else
          # New file not in snapshot
          status_info = { raw_status: 'A ', index: 'N/A', worktree: 'Added' }
          diff_info = {
            additions: count_lines(file_info[:full_path]),
            deletions: 0,
            chunks: 1
          }

          create_file_data(file_info, 'New', status_info, diff_info)
        end
      end

      def add_untracked_files_without_diff
        @files.map do |file_info|
          {
            file: file_info[:path],
            modified: file_info[:modified_time].strftime(time_format),
            modified_time: file_info[:modified_time],
            size: format_size(file_info[:size]),
            tracking: 'None',
            git_status: '--',
            index: 'N/A',
            worktree: 'N/A',
            additions: 0,
            deletions: 0,
            chunks: 0
          }
        end
      end

      def count_lines(file_path)
        File.readlines(file_path).length
      rescue StandardError
        0
      end

      def create_file_data(file_info, tracking, status_info, diff_info)
        {
          file: file_info[:path],
          modified: file_info[:modified_time].strftime(time_format),
          modified_time: file_info[:modified_time],
          size: format_size(file_info[:size]),
          tracking: tracking,
          git_status: status_info[:raw_status] || '--',
          index: status_info[:index] || 'Clean',
          worktree: status_info[:worktree] || 'Clean',
          additions: diff_info[:additions] || 0,
          deletions: diff_info[:deletions] || 0,
          chunks: diff_info[:chunks] || 0
        }
      end

      def time_format
        @config.fetch('display', 'time_format')
      end

      def format_size(bytes)
        return 'N/A' unless bytes.is_a?(Numeric)

        units = ['B', 'KB', 'MB', 'GB']
        size = bytes.to_f
        unit_index = 0

        while size >= 1024 && unit_index < units.length - 1
          size /= 1024.0
          unit_index += 1
        end

        if unit_index == 0
          ""#{size.to_i}#{units[unit_index]}""
        else
          ""#{size.round(1)}#{units[unit_index]}""
        end
      end
    end
  end
end",false
yadm_analysis_action.rb,/lib/ComputerTools/actions/file_activity/,"# frozen_string_literal: true

module ComputerTools
  module Actions
    class YadmAnalysisAction < Sublayer::Actions::Base
      def initialize(files:, config:)
        @files = files
        @config = config
      end

      def call
        return [] if @files.empty?

        unless TTY::Which.exist?('yadm')
          puts ""‚ö†Ô∏è  Warning: 'yadm' not found. Skipping YADM file processing."".colorize(:yellow)
          return []
        end

        data = []

        @files.each do |file_info|
          file_data = analyze_yadm_file(file_info)
          data << file_data if file_data
        rescue StandardError => e
          puts ""‚ö†Ô∏è  Warning: Could not analyze YADM file #{file_info[:path]}: #{e.message}"".colorize(:yellow)
        end

        data
      rescue StandardError => e
        puts ""‚ùå Error analyzing YADM files: #{e.message}"".colorize(:red)
        []
      end

      private

      def analyze_yadm_file(file_info)
        relative_path = file_info[:path]

        # Get diff information
        diff_output = `yadm diff HEAD -- ""#{relative_path}"" 2>/dev/null`
        diff_info = parse_diff_output(diff_output)

        # Get status information
        status_output = `yadm status --porcelain ""#{relative_path}"" 2>/dev/null`
        status_info = parse_status_output(status_output)

        create_file_data(file_info, 'YADM', status_info, diff_info)
      end

      def parse_diff_output(diff_output)
        {
          additions: diff_output.scan(/^\+[^+]/).length,
          deletions: diff_output.scan(/^-[^-]/).length,
          chunks: diff_output.scan(/^@@/).length
        }
      end

      def parse_status_output(status_output)
        git_status = status_output.strip.empty? ? '--' : status_output[0..1]

        {
          raw_status: git_status,
          index: git_status[0] ? status_char_to_name(git_status[0]) : 'Clean',
          worktree: git_status[1] ? status_char_to_name(git_status[1]) : 'Clean'
        }
      end

      def status_char_to_name(char)
        case char
        when 'M' then 'Modified'
        when 'A' then 'Added'
        when 'D' then 'Deleted'
        when 'R' then 'Renamed'
        when 'C' then 'Copied'
        when 'U' then 'Unmerged'
        when '?' then 'Untracked'
        when ' ' then 'Unchanged'
        else 'Unknown'
        end
      end

      def create_file_data(file_info, tracking, status_info, diff_info)
        {
          file: file_info[:path],
          modified: file_info[:modified_time].strftime(time_format),
          modified_time: file_info[:modified_time],
          size: format_size(file_info[:size]),
          tracking: tracking,
          git_status: status_info[:raw_status] || '--',
          index: status_info[:index] || 'Clean',
          worktree: status_info[:worktree] || 'Clean',
          additions: diff_info[:additions] || 0,
          deletions: diff_info[:deletions] || 0,
          chunks: diff_info[:chunks] || 0
        }
      end

      def time_format
        @config.fetch('display', 'time_format')
      end

      def format_size(bytes)
        return 'N/A' unless bytes.is_a?(Numeric)

        units = ['B', 'KB', 'MB', 'GB']
        size = bytes.to_f
        unit_index = 0

        while size >= 1024 && unit_index < units.length - 1
          size /= 1024.0
          unit_index += 1
        end

        if unit_index == 0
          ""#{size.to_i}#{units[unit_index]}""
        else
          ""#{size.round(1)}#{units[unit_index]}""
        end
      end
    end
  end
end",false
run_shell_command.rb,/lib/ComputerTools/actions/,[Binary file - content not included],true
example_agent.rb,/lib/ComputerTools/agents/,"# frozen_string_literal: true

module ComputerTools
  module Agents
    class ExampleAgent < Sublayer::Agents::Base
      trigger_on_files_changed { [""example_file.txt""] }

      goal_condition { @goal_reached }

      check_status do
        @status_checked = true
      end

      step do
        @step_taken = true
        @goal_reached = true
        puts ""Example agent step executed""
      end
    end
  end
end",false
cli.rb,/lib/ComputerTools/,"# frozen_string_literal: true

module ComputerTools
  class CLI < Thor
    excluded_commands = %i[BaseCommand MenuCommand]
    valid_commands = ComputerTools::Commands.constants.reject do |command_class|
      excluded_commands.include?(command_class)
    end

    valid_commands.each do |command_class|
      command = ComputerTools::Commands.const_get(command_class)
      desc command.command_name, command.description
      define_method(command.command_name) do |*args|
        command.new(options).execute(*args)
      end
    end

    def self.start(given_args=ARGV)
      # If no arguments provided, launch interactive menu
      if given_args.empty?
        begin
          require 'tty-prompt'
          debug_mode = ENV['COMPUTERTOOLS_DEBUG'] == 'true'
          ComputerTools::Commands::MenuCommand.new(debug: debug_mode).start
        rescue LoadError
          puts ""‚ùå TTY::Prompt not available. Please run: bundle install"".colorize(:red)
          super
        end
      else
        super
      end
    end
  end
end",false
base_command.rb,/lib/ComputerTools/commands/,"# frozen_string_literal: true

module ComputerTools
  module Commands
    class BaseCommand
      def self.command_name
        name.split(""::"").last.gsub(/Command$/, '').downcase
      end

      def self.description
        ""Description for #{command_name}""
      end

      def initialize(options)
        @options = options
      end

      def execute(*args)
        raise NotImplementedError, ""#{self.class} must implement #execute""
      end

      protected

      # Logger convenience methods for easy migration
      def logger
        ComputerTools.logger
      end

      def log_success(message, **data)
        ComputerTools.logger.success(message, **data)
      end

      def log_failure(message, **data)
        ComputerTools.logger.failure(message, **data)
      end

      def log_warning(message, **data)
        ComputerTools.logger.warn(message, **data)
      end

      def log_tip(message, **data)
        ComputerTools.logger.tip(message, **data)
      end

      def log_step(message, **data)
        ComputerTools.logger.step(message, **data)
      end

      def log_info(message, **data)
        ComputerTools.logger.info(message, **data)
      end

      def log_debug(message, **data)
        ComputerTools.logger.debug(message, **data)
      end

      def log_error(message, **data)
        ComputerTools.logger.error(message, **data)
      end
    end
  end
end",false
blueprint_command.rb,/lib/ComputerTools/commands/,"# frozen_string_literal: true

module ComputerTools
  module Commands
    class BlueprintCommand < BaseCommand
      def self.description
        ""Manage code blueprints with AI-enhanced metadata and vector search capabilities""
      end

      def initialize(options)
        super
        @subcommand = nil
        @args = []
      end

      def execute(*args)
        @subcommand = args.shift
        @args = args

        case @subcommand
        when 'submit'
          handle_submit
        when 'list'
          handle_list
        when 'browse'
          handle_browse
        when 'view'
          handle_view
        when 'edit'
          handle_edit
        when 'delete'
          handle_delete
        when 'search'
          handle_search
        when 'export'
          handle_export
        when 'config'
          handle_config
        when 'help', nil
          show_help
        else
          puts ""‚ùå Unknown subcommand: #{@subcommand}"".colorize(:red)
          show_help
          false
        end
      end

      private

      def handle_submit
        input = @args.first

        unless input
          puts ""‚ùå Please provide a file path or code string"".colorize(:red)
          puts ""Usage: blueprint submit <file_path_or_code>""
          return false
        end

        if File.exist?(input)
          puts ""üìÅ Submitting blueprint from file: #{input}"".colorize(:blue)
          code = File.read(input)
        else
          puts ""üìù Submitting blueprint from code string"".colorize(:blue)
          code = input
        end

        ComputerTools::Actions::BlueprintSubmitAction.new(
          code: code,
          auto_describe: @options['auto_describe'] != false,
          auto_categorize: @options['auto_categorize'] != false
        ).call
      end

      def handle_list
        format = (@options['format'] || 'table').to_sym
        interactive = @options['interactive'] || false

        ComputerTools::Actions::BlueprintListAction.new(
          format: format,
          interactive: interactive
        ).call
      end

      def handle_browse
        ComputerTools::Actions::BlueprintListAction.new(
          interactive: true
        ).call
      end

      def handle_view
        id = @args.first

        unless id
          puts ""‚ùå Please provide a blueprint ID"".colorize(:red)
          puts ""Usage: blueprint view <id>""
          return false
        end

        format = (@options['format'] || 'detailed').to_sym

        ComputerTools::Actions::BlueprintViewAction.new(
          id: id.to_i,
          format: format,
          with_suggestions: @options['analyze'] || false
        ).call
      end

      def handle_edit
        id = @args.first

        unless id
          puts ""‚ùå Please provide a blueprint ID"".colorize(:red)
          puts ""Usage: blueprint edit <id>""
          return false
        end

        ComputerTools::Actions::BlueprintEditAction.new(
          id: id.to_i
        ).call
      end

      def handle_delete
        # Check for force flag in arguments
        force = @args.include?('--force')

        # Get ID (first non-flag argument)
        id = @args.find { |arg| !arg.start_with?('--') }

        # If no ID provided, will trigger interactive selection
        ComputerTools::Actions::BlueprintDeleteAction.new(
          id: id&.to_i,
          force: force
        ).call
      end

      def handle_search
        query = @args.join(' ')

        if query.empty?
          puts ""‚ùå Please provide a search query"".colorize(:red)
          puts ""Usage: blueprint search <query>""
          return false
        end

        ComputerTools::Actions::BlueprintSearchAction.new(
          query: query,
          limit: @options['limit'] || 10
        ).call
      end

      def handle_export
        id = @args.first
        output_path = @args[1] || @options['output']

        unless id
          puts ""‚ùå Please provide a blueprint ID"".colorize(:red)
          puts ""Usage: blueprint export <id> [output_file]""
          return false
        end

        ComputerTools::Actions::BlueprintExportAction.new(
          id: id.to_i,
          output_path: output_path
        ).call
      end

      def handle_config
        subcommand = @args.first || 'show'

        ComputerTools::Actions::BlueprintConfigAction.new(
          subcommand: subcommand
        ).call
      end

      def show_help
        puts <<~HELP
          Blueprint Management Commands:

          üìù Content Management:
            blueprint submit <file_or_code>     Submit a new blueprint
            blueprint edit <id>                 Edit existing blueprint (delete + resubmit)
            blueprint delete [id]               Delete blueprint (interactive if no ID)
            blueprint export <id> [file]        Export blueprint code to file

          üìã Browsing & Search:
            blueprint list                      List all blueprints
            blueprint browse                    Interactive blueprint browser
            blueprint view <id>                 View specific blueprint
            blueprint search <query>            Search blueprints by content

          üîß Configuration:
            blueprint config [show|setup]      Manage configuration

          Options:
            --format FORMAT                     Output format (table, json, summary, detailed)
            --interactive                       Interactive mode with prompts
            --output FILE                       Output file path
            --analyze                          Include AI analysis and suggestions
            --force                            Skip confirmation prompts (use with caution)
            --auto_describe=false              Disable auto-description generation
            --auto_categorize=false            Disable auto-categorization

          Examples:
            blueprint submit my_code.rb
            blueprint submit 'puts ""hello world""'
            blueprint list --format summary
            blueprint browse
            blueprint view 123 --analyze
            blueprint edit 123
            blueprint delete 123
            blueprint delete --force 123
            blueprint delete                        # Interactive selection
            blueprint search ""ruby class""
            blueprint export 123 my_blueprint.rb

        HELP
      end
    end
  end
end",false
config_command.rb,/lib/ComputerTools/commands/,"# frozen_string_literal: true

module ComputerTools
  module Commands
    class ConfigCommand < BaseCommand
      def self.description
        ""Manage ComputerTools configuration settings""
      end

      def initialize(options)
        super
        @prompt = TTY::Prompt.new
      end

      def execute(*args)
        subcommand = args.shift

        case subcommand
        when 'setup', nil
          handle_setup
        when 'show'
          handle_show
        when 'edit'
          handle_edit
        when 'reset'
          handle_reset
        when 'validate'
          handle_validate
        when 'help'
          show_help
        else
          puts ""‚ùå Unknown subcommand: #{subcommand}"".colorize(:red)
          show_help
          false
        end
      end

      private

      def handle_setup
        puts ""üîß ComputerTools Configuration Setup"".colorize(:blue)
        puts ""="" * 40

        begin
          require_relative '../configuration'
          config = ComputerTools::Configuration.new
          success = config.interactive_setup

          if success
            puts ""‚úÖ Configuration setup completed successfully!"".colorize(:green)
            true
          else
            puts ""‚ö†Ô∏è  Configuration setup completed with warnings."".colorize(:yellow)
            false
          end
        rescue StandardError => e
          puts ""‚ùå Error during configuration setup: #{e.message}"".colorize(:red)
          puts ""   File: #{e.backtrace.first}"" if ENV['DEBUG']
          false
        end
      end

      def handle_show
        puts ""üìã Current Configuration"".colorize(:blue)
        puts ""="" * 25

        begin
          require_relative '../configuration'
          config = ComputerTools::Configuration.new
          config_hash = config.config.to_hash

          if config_hash.empty?
            puts ""‚ö†Ô∏è  No configuration found. Run 'config setup' to create one."".colorize(:yellow)
            return false
          end

          display_config_section(""Paths"", config_hash['paths']) if config_hash['paths']
          display_config_section(""Display"", config_hash['display']) if config_hash['display']
          display_config_section(""Restic"", config_hash['restic']) if config_hash['restic']
          display_config_section(""Terminal"", config_hash['terminal']) if config_hash['terminal']
          display_config_section(""Logger"", config_hash['logger']) if config_hash['logger']

          true
        rescue StandardError => e
          puts ""‚ùå Error reading configuration: #{e.message}"".colorize(:red)
          false
        end
      end

      def handle_edit
        puts ""‚úèÔ∏è  Interactive Configuration Editor"".colorize(:blue)
        puts ""="" * 35

        begin
          require_relative '../configuration'
          config = ComputerTools::Configuration.new

          section = @prompt.select(""Which section would you like to edit?"") do |menu|
            menu.choice ""üìÅ Paths (directories and repositories)"", :paths
            menu.choice ""üé® Display settings"", :display
            menu.choice ""üì¶ Restic backup settings"", :restic
            menu.choice ""üíª Terminal settings"", :terminal
            menu.choice ""üìù Logger settings"", :logger
            menu.choice ""üîÑ Full setup (all sections)"", :all
            menu.choice ""‚ùå Cancel"", :cancel
          end

          return true if section == :cancel

          case section
          when :paths
            config.send(:configure_paths)
          when :display
            config.send(:configure_display)
          when :restic
            config.send(:configure_restic)
          when :terminal
            config.send(:configure_terminals)
          when :logger
            config.send(:configure_logger)
          when :all
            config.interactive_setup
          end

          config.send(:save_config)
          puts ""‚úÖ Configuration updated successfully!"".colorize(:green)
          true
        rescue StandardError => e
          puts ""‚ùå Error editing configuration: #{e.message}"".colorize(:red)
          false
        end
      end

      def handle_reset
        puts ""üîÑ Reset Configuration"".colorize(:blue)
        puts ""="" * 22

        config_file = File.expand_path('~/.config/computertools/config.yml')

        if File.exist?(config_file)
          confirmed = @prompt.yes?(""‚ö†Ô∏è  This will delete your current configuration. Are you sure?"")
          return false unless confirmed

          begin
            File.delete(config_file)
            puts ""‚úÖ Configuration file deleted successfully."".colorize(:green)
            puts ""üí° Run 'config setup' to create a new configuration."".colorize(:cyan)
            true
          rescue StandardError => e
            puts ""‚ùå Error deleting configuration file: #{e.message}"".colorize(:red)
            false
          end
        else
          puts ""‚ÑπÔ∏è  No configuration file found at #{config_file}"".colorize(:blue)
          true
        end
      end

      def handle_validate
        puts ""üîç Validating Configuration"".colorize(:blue)
        puts ""="" * 26

        begin
          require_relative '../configuration'
          config = ComputerTools::Configuration.new

          # Test terminal command
          puts ""üì° Checking terminal availability..."".colorize(:cyan)
          terminals_valid = config.send(:validate_terminal_command)

          if terminals_valid
            puts ""‚úÖ Configuration validation passed!"".colorize(:green)
          else
            puts ""‚ö†Ô∏è  Configuration validation completed with warnings."".colorize(:yellow)
          end

          true
        rescue TTY::Config::ValidationError => e
          puts ""‚ùå Configuration validation failed: #{e.message}"".colorize(:red)
          false
        rescue StandardError => e
          puts ""‚ùå Error during validation: #{e.message}"".colorize(:red)
          false
        end
      end

      def display_config_section(title, data)
        puts ""\n#{title}:"".colorize(:cyan)
        case data
        when Hash
          data.each do |key, value|
            puts ""  #{key}: #{format_value(value)}""
          end
        when Array
          data.each_with_index do |item, i|
            puts ""  #{i + 1}. #{format_value(item)}""
          end
        else
          puts ""  #{format_value(data)}""
        end
      end

      def format_value(value)
        case value
        when Hash
          if value.key?('command') && value.key?('args')
            ""#{value['command']} #{value['args']}"".colorize(:yellow)
          else
            value.inspect.colorize(:yellow)
          end
        when String
          value.colorize(:yellow)
        else
          value.to_s.colorize(:yellow)
        end
      end

      def show_help
        puts <<~HELP
          Configuration Management Commands:

          üîß Setup & Management:
            config setup                         Interactive configuration setup (default)
            config show                          Display current configuration
            config edit                          Edit specific configuration sections
            config reset                         Delete configuration file
            config validate                      Validate configuration and check dependencies

          üìã Configuration Sections:
            ‚Ä¢ Paths: Home directory, restic mount point, repository paths
            ‚Ä¢ Display: Time format and output preferences#{'  '}
            ‚Ä¢ Restic: Backup mounting timeout and settings
            ‚Ä¢ Terminal: Default terminal emulator command and arguments
            ‚Ä¢ Logger: Log levels, file logging, and output preferences

          üíæ Configuration File:
            Location: ~/.config/computertools/config.yml
            Format: YAML with hierarchical sections

          Examples:
            config                               # Run interactive setup
            config show                          # View current settings
            config edit                          # Edit specific sections
            config validate                      # Check configuration validity
            config reset                         # Start fresh

          üí° Tips:
            ‚Ä¢ Use 'config setup' for first-time configuration
            ‚Ä¢ Use 'config edit' to modify specific sections only
            ‚Ä¢ Use 'config validate' to check if external tools are available

        HELP
      end
    end
  end
end",false
deepgram_command.rb,/lib/ComputerTools/commands/,"# frozen_string_literal: true

module ComputerTools
  module Commands
    # Manages command-line operations related to Deepgram output, including parsing,
    # analysis, format conversion, and configuration management.
    #
    # This class acts as a dispatcher for various Deepgram-specific subcommands,
    # allowing users to interact with Deepgram JSON data through a unified interface.
    # It delegates specific operations to dedicated action classes (e.g., for parsing,
    # analysis, conversion, and configuration).
    #
    # @see ComputerTools::Actions::DeepgramParseAction
    # @see ComputerTools::Actions::DeepgramAnalyzeAction
    # @see ComputerTools::Actions::DeepgramConvertAction
    # @see ComputerTools::Actions::DeepgramConfigAction
    class DeepgramCommand < BaseCommand
      # Returns a brief description of the command's purpose.
      #
      # This description is typically used in help menus or command listings to
      # provide a quick overview of what the `deepgram` command does.
      #
      # @return [String] A descriptive string explaining the command's functionality.
      # @example
      #   DeepgramCommand.description #=> ""Parse and analyze Deepgram JSON output with AI-enhanced insights""

      def self.description
        ""Parse and analyze Deepgram JSON output with AI-enhanced insights""
      end

      # Initializes a new DeepgramCommand instance.
      #
      # Sets up the command with an initial set of options inherited from `BaseCommand`.
      # Internal instance variables `@subcommand` and `@args` are initialized to `nil` and
      # an empty array, respectively, to be populated later by the {#execute} method.
      #
      # @param [Hash] options A hash of options, typically parsed from command-line arguments.
      #   These options are passed to the superclass initializer and can influence
      #   behavior in subsequent actions (e.g., `output` file path or `interactive` mode).

      def initialize(options)
        super
        @subcommand = nil
        @args = []
      end

      # Executes the specified Deepgram subcommand based on the provided arguments.
      #
      # This method parses the first argument as a subcommand and dispatches
      # to the appropriate private handler method (e.g., {#handle_parse},
      # {#handle_analyze}, {#handle_convert}, {#handle_config}).
      # If no subcommand or 'help' is provided, it displays the help message.
      # If an unknown subcommand is given, it logs an error and shows help.
      #
      # @param [Array<String>] args A variable number of strings representing
      #   command-line arguments. The first element is expected to be the subcommand
      #   (e.g., 'parse', 'analyze'), and subsequent elements are arguments for that subcommand.
      # @return [Boolean] `true` if a known subcommand was successfully executed or help was shown,
      #   `false` if an unknown subcommand was provided, or if a subcommand handler
      #   returned `false` due to missing/invalid input (e.g., file not found).
      # @example Parse a Deepgram JSON file to markdown and display in console
      #   command = DeepgramCommand.new({'output' => 'parsed.md'})
      #   command.execute('parse', 'transcript.json', 'markdown', '--console')
      # @example Analyze a Deepgram JSON file interactively
      #   command = DeepgramCommand.new({'interactive' => true})
      #   command.execute('analyze', 'segments.json')
      # @example Convert a Deepgram JSON file to SRT format
      #   command = DeepgramCommand.new({})
      #   command.execute('convert', 'transcript.json', 'srt')
      # @example Show the general help message for the Deepgram command
      #   command = DeepgramCommand.new({})
      #   command.execute('help')
      # @example Handle an unknown subcommand gracefully
      #   command = DeepgramCommand.new({})
      #   command.execute('unknown_command') # Logs an error and shows help, returns `false`

      def execute(*args)
        @subcommand = args.shift
        @args = args

        case @subcommand
        when 'parse'
          handle_parse
        when 'analyze'
          handle_analyze
        when 'convert'
          handle_convert
        when 'config'
          handle_config
        when 'help', nil
          show_help
        else
          puts ""‚ùå Unknown subcommand: #{@subcommand}"".colorize(:red)
          show_help
          false
        end
      end

      private

      # Handles the 'parse' subcommand, processing Deepgram JSON output.
      #
      # This method expects a JSON file path as the first element in `@args`
      # and an optional output format (defaults to 'markdown') as the second.
      # It validates the presence and existence of the JSON file, printing an
      # error message and usage instructions if validation fails.
      # Upon successful validation, it delegates the parsing operation to
      # {ComputerTools::Actions::DeepgramParseAction}.
      #
      # @return [Object, Boolean] The result of the `DeepgramParseAction.call` method
      #   if parsing proceeds, or `false` if a JSON file path is missing or the file
      #   does not exist.
      # @see ComputerTools::Actions::DeepgramParseAction

      def handle_parse
        json_file = @args.first
        output_format = @args[1] || 'markdown'

        unless json_file
          puts ""‚ùå Please provide a JSON file path"".colorize(:red)
          puts ""Usage: deepgram parse <json_file> [format]""
          puts ""Available formats: markdown, srt, json, summary""
          return false
        end

        unless File.exist?(json_file)
          puts ""‚ùå File not found: #{json_file}"".colorize(:red)
          return false
        end

        ComputerTools::Actions::DeepgramParseAction.new(
          json_file: json_file,
          output_format: output_format,
          output_file: @options['output'],
          console_output: @args.include?('--console')
        ).call
      end

      # Handles the 'analyze' subcommand, applying AI-enhanced insights to Deepgram JSON.
      #
      # This method expects a JSON file path as the first element in `@args`.
      # It validates the presence and existence of the JSON file, printing an
      # error message and usage instructions if validation fails.
      # Upon successful validation, it delegates the analysis operation to
      # {ComputerTools::Actions::DeepgramAnalyzeAction}.
      #
      # @return [Object, Boolean] The result of the `DeepgramAnalyzeAction.call` method
      #   if analysis proceeds, or `false` if a JSON file path is missing or the file
      #   does not exist.
      # @see ComputerTools::Actions::DeepgramAnalyzeAction
      def handle_analyze
        json_file = @args.first

        unless json_file
          puts ""‚ùå Please provide a JSON file path"".colorize(:red)
          puts ""Usage: deepgram analyze <json_file>""
          return false
        end

        unless File.exist?(json_file)
          puts ""‚ùå File not found: #{json_file}"".colorize(:red)
          return false
        end

        ComputerTools::Actions::DeepgramAnalyzeAction.new(
          json_file: json_file,
          interactive: @options['interactive'] || false,
          console_output: @options['console'] || false
        ).call
      end

      # Handles the 'convert' subcommand, transforming Deepgram JSON into various formats.
      #
      # This method expects a JSON file path as the first element in `@args`
      # and an optional target format (defaults to 'srt', can also be from `@options['format']`)
      # as the second. It validates the presence and existence of the JSON file,
      # printing an error message and usage instructions if validation fails.
      # Upon successful validation, it delegates the conversion operation to
      # {ComputerTools::Actions::DeepgramConvertAction}.
      #
      # @return [Object, Boolean] The result of the `DeepgramConvertAction.call` method
      #   if conversion proceeds, or `false` if a JSON file path is missing or the file
      #   does not exist.
      # @see ComputerTools::Actions::DeepgramConvertAction
      def handle_convert
        json_file = @args.first
        target_format = @args[1] || @options['format'] || 'srt'

        unless json_file
          puts ""‚ùå Please provide a JSON file path"".colorize(:red)
          puts ""Usage: deepgram convert <json_file> [format]""
          puts ""Available formats: markdown, srt, json, summary""
          return false
        end

        unless File.exist?(json_file)
          puts ""‚ùå File not found: #{json_file}"".colorize(:red)
          return false
        end

        ComputerTools::Actions::DeepgramConvertAction.new(
          json_file: json_file,
          format: target_format,
          output_file: @options['output'],
          console_output: @args.include?('--console')
        ).call
      end

      # Handles the 'config' subcommand, managing Deepgram API configuration.
      #
      # This method takes an optional subcommand (e.g., 'show' or 'setup')
      # as the first element in `@args`, defaulting to 'show' if not provided.
      # It delegates the configuration management to
      # {ComputerTools::Actions::DeepgramConfigAction}.
      #
      # @return [Object] The result of the `DeepgramConfigAction.call` method,
      #   which typically indicates the success or outcome of the configuration operation.
      # @see ComputerTools::Actions::DeepgramConfigAction
      def handle_config
        subcommand = @args.first || 'show'

        ComputerTools::Actions::DeepgramConfigAction.new(
          subcommand: subcommand
        ).call
      end

      # Displays the help message for the Deepgram command.
      #
      # This method prints a detailed usage guide to the console, including
      # available subcommands, arguments, examples, and supported output formats.
      # It is typically called when the `deepgram` command is executed with
      # 'help' or no arguments, or with an unknown subcommand.
      #
      # @return [nil] This method prints directly to stdout and does not return a meaningful value.
      def show_help
        puts <<~HELP
          Deepgram Analysis Commands:

          üìÑ Core Operations:
            deepgram parse <json_file> [format]     Parse Deepgram JSON output
            deepgram analyze <json_file>            Analyze segments with AI insights
            deepgram convert <json_file> [format]   Convert to different formats

          üîß Configuration:
            deepgram config [show|setup]           Manage configuration

          Arguments:
            format                             Output format (markdown, srt, json, summary)
            --console                          Display output in console
            --interactive                      Interactive mode for selections

          Examples:
            deepgram parse transcript.json
            deepgram parse transcript.json markdown --console
            deepgram analyze segments.json --interactive
            deepgram convert transcript.json srt
            deepgram convert transcript.json summary --console
            deepgram config setup

          Supported Formats:
            - markdown: Rich analysis with sections
            - srt: Standard subtitle format
            - json: Structured data output

        HELP
      end
    end
  end
end",false
latest_changes_command.rb,/lib/ComputerTools/commands/,"# frozen_string_literal: true

module ComputerTools
  module Commands
    class LatestChangesCommand < BaseCommand
      def self.description
        ""Analyze recent file changes across Git, YADM, and Restic tracking methods""
      end

      def initialize(options)
        super
        @directory = options['directory'] || '.'
        @time_range = options['time_range'] || '24h'
        @format = options['format'] || 'table'
        @interactive = options['interactive'] || false
      end

      def execute(*args)
        subcommand = args.shift

        case subcommand
        when 'analyze', nil
          handle_analyze
        when 'config'
          handle_config
        when 'help'
          show_help
        else
          puts ""‚ùå Unknown subcommand: #{subcommand}"".colorize(:red)
          show_help
          false
        end
      end

      private

      def handle_analyze
        puts ""üîç Analyzing recent changes in #{@directory}..."".colorize(:blue)
        puts ""‚è∞ Time range: #{@time_range}"".colorize(:cyan)

        ComputerTools::Actions::LatestChangesAction.new(
          directory: @directory,
          time_range: @time_range,
          format: @format,
          interactive: @interactive
        ).call
      end

      def handle_config
        puts ""‚öôÔ∏è  Configuration setup for file analysis..."".colorize(:blue)

        begin
          require_relative '../configuration'
          config = ComputerTools::Configuration.new
          config.interactive_setup
          puts ""‚úÖ Configuration updated successfully!"".colorize(:green)
          true
        rescue StandardError => e
          puts ""‚ùå Error in configuration setup: #{e.message}"".colorize(:red)
          puts ""   File: #{e.backtrace.first}"" if ENV['DEBUG']
          false
        end
      end

      def show_help
        puts <<~HELP
          File Activity Analysis Commands:

          üìä Analysis:
            latest-changes analyze              Analyze recent file changes (default)
            latest-changes config               Configure analysis settings

          Options:
            --directory PATH                    Directory to analyze (default: current)
            --time-range RANGE                  Time range for analysis (default: 24h)
                                               Examples: 1h, 6h, 24h, 2d, 1w
            --format FORMAT                     Output format (table, json, summary)
            --interactive                       Interactive mode with browsing

          Examples:
            latest-changes                      # Analyze current directory for last 24h
            latest-changes --directory ~/code   # Analyze specific directory
            latest-changes --time-range 7d      # Analyze last week
            latest-changes --format json        # Output as JSON
            latest-changes --interactive        # Interactive browsing mode
            latest-changes config               # Configure settings

          The analyzer tracks files across:
          ‚Ä¢ Git repositories (with diff analysis)
          ‚Ä¢ YADM dotfile management
          ‚Ä¢ Restic backup comparisons
          ‚Ä¢ Untracked files

        HELP
      end
    end
  end
end",false
menu_command.rb,/lib/ComputerTools/commands/,"# frozen_string_literal: true

module ComputerTools
  module Commands
    class MenuCommand
      def initialize(debug: false)
        @prompt = TTY::Prompt.new
        @commands = available_commands
        @debug = debug
      end

      def start
        loop do
          choice = main_menu

          # Debug logging
          debug_log(""Choice selected: #{choice.inspect} (#{choice.class})"")

          case choice
          when :exit
            puts ""üëã Goodbye!"".colorize(:green)
            break
          else
            # All command names are strings, so handle them directly
            debug_log(""Handling command: #{choice}"")
            result = handle_command(choice)
            debug_log(""Command result: #{result}"")
            # If command handler returns :exit, break the loop
            break if result == :exit
          end
        end
      end

      private

      def debug_log(message)
        puts ""üîç DEBUG: #{message}"".colorize(:magenta) if @debug
      end

      def available_commands
        excluded_commands = %i[BaseCommand MenuCommand]
        valid_commands = ComputerTools::Commands.constants.reject do |command_class|
          excluded_commands.include?(command_class)
        end

        valid_commands.map do |command_class|
          command = ComputerTools::Commands.const_get(command_class)
          {
            name: command.command_name,
            description: command.description,
            class: command
          }
        end
      end

      def main_menu
        debug_log(""Building main menu with commands: #{@commands.map { |cmd| cmd[:name] }}"")

        result = @prompt.select(""üöÄ ComputerTools - Select a command:"".colorize(:cyan)) do |menu|
          @commands.each do |cmd|
            debug_log(""Adding menu choice: '#{cmd[:name].capitalize} - #{cmd[:description]}' -> #{cmd[:name].inspect}"")
            menu.choice ""#{cmd[:name].capitalize} - #{cmd[:description]}"", cmd[:name]
          end
          menu.choice ""Exit"", :exit
        end

        debug_log(""Menu selection returned: #{result.inspect}"")
        result
      end

      def handle_command(command_name)
        debug_log(""Looking for command: #{command_name.inspect}"")
        debug_log(""Available commands: #{@commands.map { |cmd| cmd[:name] }}"")

        command_info = @commands.find { |cmd| cmd[:name] == command_name }
        debug_log(""Command found: #{command_info ? 'YES' : 'NO'}"")

        return :continue unless command_info

        debug_log(""Executing command handler for: #{command_name}"")
        case command_name
        when 'blueprint'
          handle_blueprint_command
        when 'deepgram'
          handle_deepgram_command
        when 'example'
          handle_example_command
        when 'latestchanges'
          handle_latest_changes_command
        when 'config'
          handle_config_command
        else
          puts ""‚ùå Unknown command: #{command_name}"".colorize(:red)
          :continue
        end
      end

      def handle_blueprint_command
        debug_log(""Entering handle_blueprint_command"")
        subcommand = @prompt.select(""üìã Blueprint - Choose operation:"".colorize(:blue)) do |menu|
          menu.choice ""Submit new blueprint"", ""submit""
          menu.choice ""List all blueprints"", ""list""
          menu.choice ""Browse blueprints interactively"", ""browse""
          menu.choice ""View specific blueprint"", ""view""
          menu.choice ""Edit blueprint"", ""edit""
          menu.choice ""Delete blueprint"", ""delete""
          menu.choice ""Search blueprints"", ""search""
          menu.choice ""Export blueprint"", ""export""
          menu.choice ""Configuration"", ""config""
          menu.choice ""Back to main menu"", :back
        end

        return :continue if subcommand == :back

        begin
          case subcommand
          when ""submit""
            handle_blueprint_submit
          when ""list""
            handle_blueprint_list
          when ""browse""
            execute_blueprint_command(""browse"")
          when ""view""
            handle_blueprint_view
          when ""edit""
            handle_blueprint_edit
          when ""delete""
            handle_blueprint_delete
          when ""search""
            handle_blueprint_search
          when ""export""
            handle_blueprint_export
          when ""config""
            handle_blueprint_config
          end
        rescue StandardError => e
          puts ""‚ùå Error executing blueprint command: #{e.message}"".colorize(:red)
        end

        :continue
      end

      def handle_deepgram_command
        debug_log(""Entering handle_deepgram_command"")
        subcommand = @prompt.select(""üéôÔ∏è Deepgram - Choose operation:"".colorize(:blue)) do |menu|
          menu.choice ""Parse JSON output"", ""parse""
          menu.choice ""Analyze with AI insights"", ""analyze""
          menu.choice ""Convert to different format"", ""convert""
          menu.choice ""Configuration"", ""config""
          menu.choice ""Back to main menu"", :back
        end

        return :continue if subcommand == :back

        begin
          case subcommand
          when ""parse""
            handle_deepgram_parse
          when ""analyze""
            handle_deepgram_analyze
          when ""convert""
            handle_deepgram_convert
          when ""config""
            execute_deepgram_command(""config"")
          end
        rescue StandardError => e
          puts ""‚ùå Error executing deepgram command: #{e.message}"".colorize(:red)
        end

        :continue
      end

      def handle_example_command
        debug_log(""Entering handle_example_command"")
        puts ""üéØ Running example command..."".colorize(:green)
        begin
          # Create a simple example instead of using the potentially problematic generator
          example_text = ""This is a simple example story: Once upon a time, ComputerTools was created to help "" \
                         ""developers manage their code blueprints and process Deepgram audio transcriptions. The end!""
          puts example_text.colorize(:yellow)

          # Pause to let user read the output
          @prompt.keypress(""Press any key to continue..."")
        rescue StandardError => e
          puts ""‚ùå Error running example: #{e.message}"".colorize(:red)
        end
        :continue
      end

      def handle_latest_changes_command
        debug_log(""Entering handle_latest_changes_command"")
        
        subcommand = @prompt.select(""üìä Latest Changes - Choose operation:"".colorize(:blue)) do |menu|
          menu.choice ""Analyze recent changes"", ""analyze""
          menu.choice ""Configure settings"", ""config""
          menu.choice ""Help"", ""help""
          menu.choice ""Back to main menu"", :back
        end

        return :continue if subcommand == :back

        case subcommand
        when ""analyze""
          handle_latest_changes_analyze
        when ""config""
          handle_latest_changes_config
        when ""help""
          handle_latest_changes_help
        end
        :continue
      end

      # Command execution helpers
      def execute_blueprint_command(subcommand, *)
        blueprint_command = ComputerTools::Commands::BlueprintCommand.new({})
        blueprint_command.execute(subcommand, *)
      end

      def execute_deepgram_command(subcommand, *)
        deepgram_command = ComputerTools::Commands::DeepgramCommand.new({})
        deepgram_command.execute(subcommand, *)
      end

      # Blueprint subcommand handlers
      def handle_blueprint_submit
        input = @prompt.ask(""üìÅ Enter file path or code string:"")
        return if input.nil? || input.empty?

        auto_describe = @prompt.yes?(""ü§ñ Auto-generate description?"")
        auto_categorize = @prompt.yes?(""üè∑Ô∏è Auto-categorize?"")

        args = [input]
        options = {}
        options['auto_describe'] = false unless auto_describe
        options['auto_categorize'] = false unless auto_categorize

        blueprint_command = ComputerTools::Commands::BlueprintCommand.new(options)
        blueprint_command.execute('submit', *args)
      end

      def handle_blueprint_list
        format = @prompt.select(""üìä Choose format:"") do |menu|
          menu.choice ""Table"", ""table""
          menu.choice ""Summary"", ""summary""
          menu.choice ""JSON"", ""json""
        end

        interactive = @prompt.yes?(""üîÑ Interactive mode?"")

        options = { 'format' => format }
        options['interactive'] = true if interactive

        blueprint_command = ComputerTools::Commands::BlueprintCommand.new(options)
        blueprint_command.execute('list')
      end

      def handle_blueprint_view
        id = @prompt.ask(""üîç Enter blueprint ID:"")
        return if id.nil? || id.empty?

        format = @prompt.select(""üìä Choose format:"") do |menu|
          menu.choice ""Detailed"", ""detailed""
          menu.choice ""Summary"", ""summary""
          menu.choice ""JSON"", ""json""
        end

        analyze = @prompt.yes?(""üß† Include AI analysis?"")

        options = { 'format' => format }
        options['analyze'] = true if analyze

        blueprint_command = ComputerTools::Commands::BlueprintCommand.new(options)
        blueprint_command.execute('view', id)
      end

      def handle_blueprint_edit
        id = @prompt.ask(""‚úèÔ∏è Enter blueprint ID to edit:"")
        return if id.nil? || id.empty?

        blueprint_command = ComputerTools::Commands::BlueprintCommand.new({})
        blueprint_command.execute('edit', id)
      end

      def handle_blueprint_delete
        # Give user options: enter ID or select interactively
        choice = @prompt.select(""üóëÔ∏è How would you like to select the blueprint to delete?"") do |menu|
          menu.choice ""Enter blueprint ID"", ""id""
          menu.choice ""Select from list"", ""interactive""
        end

        case choice
        when ""id""
          id = @prompt.ask(""üóëÔ∏è Enter blueprint ID to delete:"")
          return if id.nil? || id.empty?

          # Ask about force deletion
          force = @prompt.yes?(""‚ö†Ô∏è Skip confirmation? (Use with caution)"")

          args = [id]
          args << ""--force"" if force

          blueprint_command = ComputerTools::Commands::BlueprintCommand.new({})
          blueprint_command.execute('delete', *args)
        when ""interactive""
          # Use interactive selection (no ID provided)
          blueprint_command = ComputerTools::Commands::BlueprintCommand.new({})
          blueprint_command.execute('delete')
        end
      end

      def handle_blueprint_search
        query = @prompt.ask(""üîç Enter search query:"")
        return if query.nil? || query.empty?

        limit = @prompt.ask(""üìä Number of results (default 10):"", default: ""10"")

        options = { 'limit' => limit.to_i }
        blueprint_command = ComputerTools::Commands::BlueprintCommand.new(options)
        blueprint_command.execute('search', query)
      end

      def handle_blueprint_export
        id = @prompt.ask(""üì§ Enter blueprint ID to export:"")
        return if id.nil? || id.empty?

        output_path = @prompt.ask(""üíæ Output file path (optional):"")

        args = [id]
        args << output_path unless output_path.nil? || output_path.empty?

        blueprint_command = ComputerTools::Commands::BlueprintCommand.new({})
        blueprint_command.execute('export', *args)
      end

      def handle_blueprint_config
        subcommand = @prompt.select(""‚öôÔ∏è Configuration:"") do |menu|
          menu.choice ""Show current config"", ""show""
          menu.choice ""Setup configuration"", ""setup""
        end

        blueprint_command = ComputerTools::Commands::BlueprintCommand.new({})
        blueprint_command.execute('config', subcommand)
      end

      # Deepgram subcommand handlers
      def handle_deepgram_parse
        json_file = @prompt.ask(""üìÅ Enter JSON file path:"")
        return if json_file.nil? || json_file.empty?

        format = @prompt.select(""üìä Choose output format:"") do |menu|
          menu.choice ""Markdown"", ""markdown""
          menu.choice ""SRT"", ""srt""
          menu.choice ""JSON"", ""json""
          menu.choice ""Summary"", ""summary""
        end

        console_output = @prompt.yes?(""üñ•Ô∏è Display in console?"")
        output_file = @prompt.ask(""üíæ Output file path (optional):"")

        args = [json_file, format]
        options = {}
        options['console'] = true if console_output
        options['output'] = output_file unless output_file.nil? || output_file.empty?

        deepgram_command = ComputerTools::Commands::DeepgramCommand.new(options)
        deepgram_command.execute('parse', *args)
      end

      def handle_deepgram_analyze
        json_file = @prompt.ask(""üìÅ Enter JSON file path:"")
        return if json_file.nil? || json_file.empty?

        interactive = @prompt.yes?(""üîÑ Interactive mode?"")
        console_output = @prompt.yes?(""üñ•Ô∏è Display in console?"")

        options = {}
        options['interactive'] = true if interactive
        options['console'] = true if console_output

        deepgram_command = ComputerTools::Commands::DeepgramCommand.new(options)
        deepgram_command.execute('analyze', json_file)
      end

      def handle_deepgram_convert
        json_file = @prompt.ask(""üìÅ Enter JSON file path:"")
        return if json_file.nil? || json_file.empty?

        format = @prompt.select(""üìä Choose target format:"") do |menu|
          menu.choice ""Markdown"", ""markdown""
          menu.choice ""SRT"", ""srt""
          menu.choice ""JSON"", ""json""
          menu.choice ""Summary"", ""summary""
        end

        console_output = @prompt.yes?(""üñ•Ô∏è Display in console?"")
        output_file = @prompt.ask(""üíæ Output file path (optional):"")

        args = [json_file, format]
        options = {}
        options['console'] = true if console_output
        options['output'] = output_file unless output_file.nil? || output_file.empty?

        deepgram_command = ComputerTools::Commands::DeepgramCommand.new(options)
        deepgram_command.execute('convert', *args)
      end

      # Latest Changes subcommand handlers
      def handle_latest_changes_analyze
        directory = @prompt.ask(""üìÅ Directory to analyze (default: current):"", default: ""."")
        
        time_range = @prompt.select(""‚è∞ Time range:"") do |menu|
          menu.choice ""Last hour"", ""1h""
          menu.choice ""Last 6 hours"", ""6h""
          menu.choice ""Last 24 hours"", ""24h""
          menu.choice ""Last 2 days"", ""2d""
          menu.choice ""Last week"", ""7d""
          menu.choice ""Custom"", ""custom""
        end

        if time_range == ""custom""
          time_range = @prompt.ask(""Enter custom time range (e.g., 3h, 5d, 2w):"")
        end

        format = @prompt.select(""üìä Output format:"") do |menu|
          menu.choice ""Table"", ""table""
          menu.choice ""Summary"", ""summary""
          menu.choice ""JSON"", ""json""
        end

        interactive = @prompt.yes?(""üîÑ Interactive mode?"")

        options = {
          'directory' => directory,
          'time_range' => time_range,
          'format' => format
        }
        options['interactive'] = true if interactive

        latest_changes_command = ComputerTools::Commands::LatestChangesCommand.new(options)
        latest_changes_command.execute('analyze')
      end

      def handle_latest_changes_config
        latest_changes_command = ComputerTools::Commands::LatestChangesCommand.new({})
        latest_changes_command.execute('config')
      end

      def handle_latest_changes_help
        latest_changes_command = ComputerTools::Commands::LatestChangesCommand.new({})
        latest_changes_command.execute('help')
      end

      def handle_config_command
        debug_log(""Entering handle_config_command"")
        
        subcommand = @prompt.select(""‚öôÔ∏è  Configuration - Choose operation:"".colorize(:blue)) do |menu|
          menu.choice ""üîß Setup configuration"", ""setup""
          menu.choice ""üìã Show current config"", ""show""
          menu.choice ""‚úèÔ∏è  Edit configuration"", ""edit""
          menu.choice ""üîç Validate configuration"", ""validate""
          menu.choice ""üîÑ Reset configuration"", ""reset""
          menu.choice ""‚ùì Help"", ""help""
          menu.choice ""Back to main menu"", :back
        end

        return :continue if subcommand == :back

        begin
          config_command = ComputerTools::Commands::ConfigCommand.new({})
          config_command.execute(subcommand)
        rescue StandardError => e
          puts ""‚ùå Error executing config command: #{e.message}"".colorize(:red)
        end

        :continue
      end
    end
  end
end",false
overview_command.rb,/lib/ComputerTools/commands/,"# frozen_string_literal: true

module ComputerTools
  module Commands
    class OverviewCommand < BaseCommand
      def self.description
        ""Display comprehensive overview of ComputerTools features and functionality""
      end

      def execute(*args)
        format = args.first || 'console'

        output_format = case format.downcase
                        when 'markdown', 'md'
                          'markdown'
                        when 'json'
                          'json'
                        else
                          'console'
                        end

        result = ComputerTools::Generators::OverviewGenerator.new(
          format: output_format
        ).generate

        puts result
      end
    end
  end
end",false
blueprints.yml,/lib/ComputerTools/config/,"# Blueprint Configuration
# This file configures the blueprint management system for direct database operations
# and AI-enhanced features using the Sublayer framework.

# Database Configuration
# Direct PostgreSQL connection with pgvector support for embeddings
database:
  url: ""postgresql://postgres:blueprints@ninjabot:5433/blueprints_development""

# Legacy API URL (deprecated - now using direct database access)
api_url: ""http://ninjabot:81""

# AI Configuration
# For generating descriptions, categories, and embeddings
ai:
  provider: ""gemini""  # gemini or openai
  model: ""text-embedding-004""  # Google Gemini embedding model
  # API keys should be set via environment variables:
  # - GEMINI_API_KEY (for Google Gemini)
  # - OPENAI_API_KEY (for OpenAI)

# Editor Configuration
# For blueprint editing operations
editor: ""micro""              # Current preference from existing config
pager: ""most""               # Current preference from existing config
auto_save_edits: true       # Current setting preserved
temp_dir: ""/tmp""            # Current setting preserved

# Feature Flags
# Control AI-enhanced features
features:
  auto_description: true     # Auto-generate descriptions for new blueprints
  auto_categorize: true      # Auto-generate categories for new blueprints
  improvement_analysis: true # Enable AI improvement suggestions

# Search Configuration
search:
  default_limit: 10          # Default number of search results
  semantic_search: true      # Use vector similarity search (requires embeddings)
  text_search_fallback: true # Fall back to text search if semantic search fails

# Export Configuration
export:
  include_metadata: false    # Include blueprint metadata in exports by default
  auto_detect_extension: true # Auto-detect file extension from code content

# Development and Debugging
debug: true                  # Current setting preserved
log_level: ""debug""          # Set to debug since debug is enabled

# Performance Configuration
performance:
  batch_size: 100           # Batch size for bulk operations
  connection_pool_size: 5   # Database connection pool size

# UI Configuration
ui:
  colors: true              # Enable colored output
  interactive: true         # Enable interactive prompts when available
  pager: true              # Use pager for long output",false
deepgram.yml,/lib/ComputerTools/config/,"---
output:
  default_format: markdown
  auto_timestamp: true
  include_confidence: true
ai:
  provider: gemini
  model: gemini-2.0-flash
  enable_insights: true
  enable_summaries: true
formats:
  srt:
    include_milliseconds: true
    line_length: 42
  markdown:
    include_stats: true
    include_metadata: true",false
sublayer.yml,/lib/ComputerTools/config/,"---
:project_name: ComputerTools
:project_template: CLI
:ai_provider: Gemini
:ai_model: gemini-2.0-flash",false
config.rb,/lib/ComputerTools/,"# frozen_string_literal: true

module ComputerTools
  module Config
    def self.load
      config_path = File.join(File.dirname(__FILE__), ""config"", ""sublayer.yml"")

      if File.exist?(config_path)
        config = YAML.load_file(config_path)

        Sublayer.configure do |c|
          c.ai_provider = Object.const_get(""Sublayer::Providers::#{config[:ai_provider]}"")
          c.ai_model = config[:ai_model]
          c.logger = Sublayer::Logging::JsonLogger.new(File.join(Dir.pwd, 'log', 'sublayer.log'))
        end
      else
        puts ""Warning: config/sublayer.yml not found. Using default configuration.""
      end
    end
  end
end",false
configuration.rb,/lib/ComputerTools/,"# frozen_string_literal: true

module ComputerTools
  class Configuration
    def initialize
      @config_file = File.expand_path('~/.config/computertools/config.yml')
      @config = TTY::Config.new
      @config.filename = 'config'
      @config.extname = '.yml'
      @config.append_path(File.dirname(@config_file))
      @config.env_prefix = 'COMPUTERTOOLS'
      @prompt = TTY::Prompt.new
      load_config
    end

    attr_reader :config

    def interactive_setup
      puts ""üîß ComputerTools Configuration Setup"".colorize(:blue)
      puts ""="" * 40

      # Set up defaults if config is empty
      setup_defaults unless @config.exist?

      # Configure paths
      configure_paths
      configure_display
      configure_restic
      configure_terminals
      configure_logger

      save_config
      puts ""\n‚úÖ Configuration saved to #{@config_file}"".colorize(:green)
    rescue TTY::Config::ValidationError => e
      puts ""\n‚ùå Configuration validation failed: #{e.message}"".colorize(:red)
      puts ""üîÑ Please check your input and try again."".colorize(:yellow)
      false
    rescue StandardError => e
      puts ""\n‚ùå Setup failed: #{e.message}"".colorize(:red)
      puts ""üîÑ Using default configuration."".colorize(:yellow)
      setup_defaults
      false
    end

    # Compatibility method for the fetch pattern used in the original code
    def fetch(*keys)
      @config.fetch(*keys)
    rescue StandardError => e
      puts ""‚ö†Ô∏è  Warning: Failed to fetch config key #{keys.join('.')}: #{e.message}"".colorize(:yellow) if ENV['DEBUG']
      nil
    end

    private

    def load_config
      if @config.exist?
        begin
          @config.read
          puts ""üìÅ Loaded configuration from #{@config_file}"".colorize(:green) if ENV['DEBUG']
        rescue TTY::Config::ReadError => e
          puts ""‚ùå Failed to read configuration file: #{e.message}"".colorize(:red)
          puts ""üîÑ Using default configuration instead."".colorize(:yellow)
          setup_defaults
        rescue TTY::Config::ValidationError => e
          puts ""‚ùå Configuration validation failed: #{e.message}"".colorize(:red)
          puts ""üîÑ Using default configuration instead."".colorize(:yellow)
          setup_defaults
        end
      else
        setup_defaults
        puts ""‚ö†Ô∏è  Using default configuration. Run 'latest-changes config' to customize."".colorize(:yellow)
      end
    rescue StandardError => e
      puts ""‚ùå Unexpected error loading configuration: #{e.message}"".colorize(:red)
      puts ""üîÑ Using default configuration."".colorize(:yellow)
      setup_defaults
    end

    def save_config
      TTY::File.create_directory(File.dirname(@config_file), verbose: false)

      # Use TTY::File for collision detection and user interaction
      if File.exist?(@config_file)
        # Create a backup before overwriting
        backup_file = ""#{@config_file}.backup.#{Time.now.strftime('%Y%m%d_%H%M%S')}""
        TTY::File.copy_file(@config_file, backup_file, verbose: false)
        puts ""üìã Created backup at #{backup_file}"".colorize(:blue) if ENV['DEBUG']
      end

      @config.write(create: true, force: true)
    rescue TTY::Config::WriteError => e
      puts ""‚ùå Failed to save configuration: #{e.message}"".colorize(:red)
      raise
    end

    # Create configuration file with user interaction and collision detection
    def create_config_file_interactive
      content = @config.marshal(@config.to_hash)

      TTY::File.create_file(
        @config_file, content,
        verbose: true,
        color: :green,
        force: false, # Don't force overwrite - let user decide
        skip: false
      ) # Don't skip - show collision options
    rescue TTY::File::InvalidPathError => e
      puts ""‚ùå Invalid path: #{e.message}"".colorize(:red)
      false
    end

    # Check if external command is available using Terrapin
    def command_available?(command)
      cmd = Terrapin::CommandLine.new(""which"", "":command"", command: command)
      cmd.run
      true
    rescue Terrapin::CommandNotFoundError, Terrapin::ExitStatusError
      false
    rescue StandardError => e
      puts ""‚ö†Ô∏è  Warning: Could not check for command '#{command}': #{e.message}"".colorize(:yellow) if ENV['DEBUG']
      false
    end

    # Validate terminal command availability
    def validate_terminal_command
      command = @config.fetch(:terminal, 'kitty')

      if command_available?(command)
        puts ""‚úÖ Terminal '#{command}' is available"".colorize(:green) if ENV['DEBUG']
        true
      else
        puts ""‚ö†Ô∏è  Terminal '#{command}' is not available on this system"".colorize(:yellow)
        false
      end
    rescue StandardError => e
      puts ""‚ùå Failed to validate terminal command: #{e.message}"".colorize(:red)
      false
    end

    def setup_defaults
      @config.set(:paths, :home_dir, value: File.expand_path('~'))
      @config.set(:paths, :restic_mount_point, value: File.expand_path('~/mnt/restic'))
      @config.set(:paths, :restic_repo, value: ENV['RESTIC_REPOSITORY'] || '/path/to/restic/repo')

      @config.set(:display, :time_format, value: '%Y-%m-%d %H:%M:%S')

      @config.set(:restic, :mount_timeout, value: 60)

      @config.set(:terminal, :command, value: 'kitty')
      @config.set(:terminal, :args, value: '-e')

      # Logger defaults
      @config.set(:logger, :level, value: 'info')
      @config.set(:logger, :file_logging, value: false)
      @config.set(:logger, :file_path, value: default_log_path_for_config)
      @config.set(:logger, :file_level, value: 'debug')

      setup_environment_variables
      setup_validators

      puts ""‚úÖ Default configuration loaded successfully"".colorize(:green) if ENV['DEBUG']
    rescue StandardError => e
      puts ""‚ùå Failed to set up default configuration: #{e.message}"".colorize(:red)
      raise
    end

    def setup_environment_variables
      # Map configuration keys to environment variables
      @config.set_from_env(:paths, :home_dir) { 'COMPUTERTOOLS_HOME_DIR' }
      @config.set_from_env(:paths, :restic_mount_point) { 'COMPUTERTOOLS_RESTIC_MOUNT_POINT' }
      @config.set_from_env(:paths, :restic_repo) { 'RESTIC_REPOSITORY' }
      @config.set_from_env(:display, :time_format) { 'COMPUTERTOOLS_TIME_FORMAT' }
      @config.set_from_env(:restic, :mount_timeout) { 'COMPUTERTOOLS_RESTIC_TIMEOUT' }
      @config.set_from_env(:terminal, :command) { 'COMPUTERTOOLS_TERMINAL_COMMAND' }
      @config.set_from_env(:terminal, :args) { 'COMPUTERTOOLS_TERMINAL_ARGS' }
      @config.set_from_env(:logger, :level) { 'COMPUTERTOOLS_LOG_LEVEL' }
      @config.set_from_env(:logger, :file_logging) { 'COMPUTERTOOLS_LOG_FILE_ENABLED' }
      @config.set_from_env(:logger, :file_path) { 'COMPUTERTOOLS_LOG_FILE_PATH' }
      @config.set_from_env(:logger, :file_level) { 'COMPUTERTOOLS_LOG_FILE_LEVEL' }
    end

    def setup_validators
      # Validate that home directory exists
      @config.validate(:paths, :home_dir) do |_key, value|
        unless Dir.exist?(File.expand_path(value))
          raise TTY::Config::ValidationError, ""Home directory '#{value}' does not exist""
        end
      end

      # Validate mount timeout is a positive integer
      @config.validate(:restic, :mount_timeout) do |_key, value|
        unless value.is_a?(Integer) && value > 0
          raise TTY::Config::ValidationError, ""Mount timeout must be a positive integer, got '#{value}'""
        end
      end

      # Validate time format string
      @config.validate(:display, :time_format) do |_key, value|
        Time.now.strftime(value)
      rescue ArgumentError => e
        raise TTY::Config::ValidationError, ""Invalid time format '#{value}': #{e.message}""
      end

      # Validate terminal command
      @config.validate(:terminal, :command) do |_key, value|
        unless value.is_a?(String) && !value.empty?
          raise TTY::Config::ValidationError, ""Terminal command must be a non-empty string""
        end
      end

      # Validate terminal args
      @config.validate(:terminal, :args) do |_key, value|
        raise TTY::Config::ValidationError, ""Terminal args must be a string"" unless value.is_a?(String)
      end
    end

    def configure_paths
      puts ""\nüìÅ Path Configuration"".colorize(:blue)

      current_home = @config.fetch(:paths) { File.expand_path('~') }
      home_dir = @prompt.ask(""Home directory:"", default: current_home)
      @config.set(:paths, :home_dir, value: home_dir)

      current_mount = @config.fetch(:paths) { File.expand_path('~/mnt/restic') }
      mount_point = @prompt.ask(""Restic mount point:"", default: current_mount)
      @config.set(:paths, :restic_mount_point, value: mount_point)

      current_repo = @config.fetch(:paths) { ENV['RESTIC_REPOSITORY'] || '/path/to/restic/repo' }
      repo = @prompt.ask(""Restic repository:"", default: current_repo)
      @config.set(:paths, :restic_repo, value: repo)
    end

    def configure_display
      puts ""\nüé® Display Configuration"".colorize(:blue)

      current_format = @config.fetch(:display, '%Y-%m-%d %H:%M:%S')
      time_format = @prompt.ask(""Time format:"", default: current_format)
      @config.set(:display, :time_format, value: time_format)
    end

    def configure_restic
      puts ""\nüì¶ Restic Configuration"".colorize(:blue)

      current_timeout = @config.fetch(:restic, 60)
      timeout = @prompt.ask(""Mount timeout in seconds:"", default: current_timeout, convert: :int) do |q|
        q.validate(/^\d+$/, ""Please enter a positive integer"")
        q.modify :strip
      end
      @config.set(:restic, :mount_timeout, value: timeout)
    end

    def configure_terminals
      puts ""\nüíª Terminal Configuration"".colorize(:blue)

      current_command = @config.fetch(:terminal, 'kitty')
      current_args = @config.fetch(:terminal, '-e')

      puts ""Current terminal: #{current_command} #{current_args}"".colorize(:cyan)

      command = @prompt.ask(""Terminal command:"", default: current_command)
      @config.set(:terminal, :command, value: command)

      args = @prompt.ask(""Terminal arguments:"", default: current_args)
      @config.set(:terminal, :args, value: args)
    end

    def configure_logger
      puts ""\nüìù Logger Configuration"".colorize(:blue)

      current_level = @config.fetch(:logger, :level) { 'info' }
      level = @prompt.select(""Console log level:"", %w[debug info warn error], default: current_level)
      @config.set(:logger, :level, value: level)

      enable_file_logging = @prompt.yes?(""Enable logging to a file?"", default: @config.fetch(:logger, :file_logging))
      @config.set(:logger, :file_logging, value: enable_file_logging)

      return unless enable_file_logging

      current_path = @config.fetch(:logger, :file_path) { default_log_path_for_config }
      path = @prompt.ask(""Log file path:"", default: current_path)
      @config.set(:logger, :file_path, value: path)

      current_file_level = @config.fetch(:logger, :file_level) { 'debug' }
      file_level = @prompt.select(""File log level:"", %w[debug info warn error], default: current_file_level)
      @config.set(:logger, :file_level, value: file_level)
    end

    def default_log_path_for_config
      state_home = ENV['XDG_STATE_HOME'] || File.expand_path('~/.local/state')
      File.join(state_home, 'computertools', 'app.log')
    end
  end
end",false
blueprint_category_generator.rb,/lib/ComputerTools/generators/blueprint/,"# frozen_string_literal: true

module ComputerTools
  module Generators
    class BlueprintCategoryGenerator < Sublayer::Generators::Base
      llm_output_adapter type: :list_of_strings,
        name: ""categories"",
        description: ""Relevant categories and tags for this code blueprint""

      def initialize(code:, description: nil)
        @code = code
        @description = description
      end

      def generate
        super
      end

      def prompt
        content_to_analyze = [@description, @code].compact.join(""\n\n"")

        <<-PROMPT
          Analyze this code and generate relevant categories/tags for organization and discovery.

          #{@description ? ""Description: #{@description}"" : """"}

          Code:
          ```
          #{@code}
          ```

          Please categorize this code with 2-4 relevant tags from the following categories:

          **Programming Languages & Frameworks:**
          ruby, python, javascript, rails, react, vue, express, flask, django

          **Application Types:**
          web-app, api, cli-tool, library, script, microservice, database-migration

          **Domain Areas:**
          authentication, authorization, data-processing, file-handling, web-scraping, 
          text-processing, image-processing, email, notifications, logging, monitoring

          **Patterns & Concepts:**
          mvc, rest-api, graphql, async, background-jobs, caching, testing, validation,
          error-handling, configuration, security, performance-optimization

          **Technical Areas:**
          database, orm, sql, nosql, redis, elasticsearch, docker, kubernetes, 
          json, xml, csv, pdf, encryption, oauth, jwt

          **Utility Types:**
          utility, helper, wrapper, adapter, parser, formatter, converter, generator

          Return only the most relevant 2-4 categories that best describe this code.
          Choose existing categories when possible rather than creating new ones.
        PROMPT
      end
    end
  end
end",false
blueprint_description_generator.rb,/lib/ComputerTools/generators/blueprint/,"# frozen_string_literal: true

module ComputerTools
  module Generators
    class BlueprintDescriptionGenerator < Sublayer::Generators::Base
      llm_output_adapter type: :single_string,
        name: ""description"",
        description: ""A clear, concise description of what this code blueprint accomplishes""

      def initialize(code:, language: nil)
        @code = code
        @language = language || detect_language(code)
      end

      def generate
        super
      end

      def prompt
        <<-PROMPT
          Analyze this #{@language} code and generate a clear, concise description of what it does.

          Code:
          ```#{@language}
          #{@code}
          ```

          Please provide a description that:
          - Explains the primary functionality in 1-2 sentences
          - Mentions key design patterns or techniques used
          - Indicates the intended use case or context
          - Is written for developers who might want to reuse this code

          Focus on WHAT the code does and WHY someone would use it, not HOW it works in detail.
        PROMPT
      end

      private

      def detect_language(code)
        case code
        when /class\s+\w+.*<.*ApplicationRecord/m, /def\s+\w+.*end/m, /require ['""].*['""]/m
          'ruby'
        when /function\s+\w+\s*\(/m, /const\s+\w+\s*=/m, /import\s+.*from/m
          'javascript'
        when /def\s+\w+\s*\(/m, /import\s+\w+/m, /from\s+\w+\s+import/m
          'python'
        when /#include\s*<.*>/m, /int\s+main\s*\(/m
          'c'
        when /public\s+class\s+\w+/m, /import\s+java\./m
          'java'
        when /fn\s+\w+\s*\(/m, /use\s+std::/m
          'rust'
        when /func\s+\w+\s*\(/m, /package\s+main/m
          'go'
        else
          'code'
        end
      end
    end
  end
end",false
blueprint_improvement_generator.rb,/lib/ComputerTools/generators/blueprint/,"# frozen_string_literal: true

module ComputerTools
  module Generators
    class BlueprintImprovementGenerator < Sublayer::Generators::Base
      llm_output_adapter type: :list_of_strings,
        name: ""improvements"",
        description: ""Suggested improvements and best practices for this code blueprint""

      def initialize(code:, description: nil)
        @code = code
        @description = description
      end

      def generate
        super
      end

      def prompt
        <<-PROMPT
          Analyze this code blueprint and suggest specific, actionable improvements.

          #{@description ? ""Description: #{@description}"" : """"}

          Code:
          ```
          #{@code}
          ```

          Please provide 3-6 specific improvement suggestions focusing on:

          **Code Quality:**
          - Readability and clarity improvements
          - Better variable/method naming
          - Code organization and structure
          - DRY principle violations

          **Performance:**
          - Algorithm efficiency improvements
          - Memory usage optimizations
          - Database query optimizations (if applicable)
          - Caching opportunities

          **Security:**
          - Input validation and sanitization
          - Authentication and authorization concerns
          - Data exposure risks
          - Secure coding practices

          **Best Practices:**
          - Framework-specific conventions
          - Error handling improvements
          - Logging and debugging enhancements
          - Testing considerations

          **Maintainability:**
          - Documentation needs
          - Configuration externalization
          - Dependency management
          - Code modularity

          Format each suggestion as a single, actionable sentence that clearly explains:
          1. WHAT to improve
          2. WHY it's important
          3. HOW to implement it (briefly)

          Focus on the most impactful improvements first. Avoid generic advice.
        PROMPT
      end
    end
  end
end",false
blueprint_name_generator.rb,/lib/ComputerTools/generators/blueprint/,"# frozen_string_literal: true

module ComputerTools
  module Generators
    class BlueprintNameGenerator < Sublayer::Generators::Base
      llm_output_adapter type: :single_string,
        name: ""name"",
        description: ""A descriptive name for this code blueprint""

      def initialize(code:, description: nil)
        @code = code
        @description = description
      end

      def generate
        super
      end

      def prompt
        <<-PROMPT
          Generate a clear, descriptive name for this code blueprint.

          #{@description ? ""Description: #{@description}"" : """"}

          Code:
          ```
          #{@code}
          ```

          The name should:
          - Be 3-6 words long
          - Clearly indicate what the code does
          - Use title case (e.g., ""User Authentication Helper"", ""CSV Data Processor"")
          - Be specific enough to distinguish it from similar code
          - Avoid generic terms like ""Script"" or ""Code"" unless necessary

          Examples of good names:
          - ""REST API Response Formatter""
          - ""Database Migration Helper""
          - ""Email Template Generator""
          - ""JWT Token Validator""
          - ""File Upload Handler""

          Return only the name, no additional text or explanation.
        PROMPT
      end
    end
  end
end",false
deepgram_insights_generator.rb,/lib/ComputerTools/generators/deepgram/,"# frozen_string_literal: true

module ComputerTools
  module Generators
    class DeepgramInsightsGenerator < Sublayer::Generators::Base
      llm_output_adapter type: :single_string,
                         name:        ""insights"",
                         description: ""Strategic insights and analysis derived from the transcript""

      def initialize(transcript:, topics: [], intents: [], context: nil)
        @transcript = transcript
        @topics = topics
        @intents = intents
        @context = context
      end

      def generate
        super
      end

      def prompt
        <<-PROMPT
          Analyze this transcript to extract strategic insights and actionable intelligence.

          Transcript:
          #{@transcript}

          #{topics_section}
          #{intents_section}
          #{context_section}

          Please provide insights that include:

          ## Strategic Analysis
          - Key business or technical patterns
          - Decision-making processes observed
          - Communication effectiveness
          - Knowledge gaps or opportunities

          ## Behavioral Insights
          - Speaking patterns and engagement levels
          - Collaboration dynamics
          - Problem-solving approaches
          - Emotional undertones

          ## Actionable Recommendations
          - Immediate action items
          - Process improvements
          - Follow-up suggestions
          - Risk mitigation strategies

          ## Content Intelligence
          - Information hierarchy and importance
          - Missing information or perspectives
          - Technical vs. non-technical content balance
          - Audience appropriateness

          Focus on providing valuable insights that go beyond surface-level content analysis.
          Consider both explicit information and implicit patterns in the conversation.
        PROMPT
      end

      private

      def topics_section
        return """" if @topics.empty?

        topics_list = @topics.map { |t| ""- #{t[:topic]}"" }.join(""\n"")
        ""\nIdentified Topics:\n#{topics_list}\n""
      end

      def intents_section
        return """" if @intents.empty?

        intents_list = @intents.map { |i| ""- #{i[:intent]} (#{i[:start]} - #{i[:end]})"" }.join(""\n"")
        ""\nDetected Intents:\n#{intents_list}\n""
      end

      def context_section
        return """" unless @context

        ""\nAdditional Context:\n#{@context}\n""
      end
    end
  end
end",false
deepgram_summary_generator.rb,/lib/ComputerTools/generators/deepgram/,"# frozen_string_literal: true

module ComputerTools
  module Generators
    class DeepgramSummaryGenerator < Sublayer::Generators::Base
      llm_output_adapter type: :single_string,
                         name:        ""summary"",
                         description: ""A comprehensive summary of the transcript content""

      def initialize(transcript:, topics: [], intents: [])
        @transcript = transcript
        @topics = topics
        @intents = intents
      end

      def generate
        super
      end

      def prompt
        <<-PROMPT
          Analyze this transcript and generate a comprehensive summary.

          Transcript:
          #{@transcript}

          #{topics_section}
          #{intents_section}

          Please provide a summary that includes:
          1. Main topics and themes discussed
          2. Key points and takeaways
          3. Important decisions or action items mentioned
          4. Overall tone and context of the conversation
          5. Any notable patterns or insights

          The summary should be well-structured and professional, suitable for:
          - Executive briefings
          - Meeting minutes
          - Content analysis reports
          - Documentation purposes

          Focus on extracting the most valuable and actionable information from the transcript.
        PROMPT
      end

      private

      def topics_section
        return """" if @topics.empty?

        topics_list = @topics.map { |t| ""- #{t[:topic]}"" }.join(""\n"")
        ""\nIdentified Topics:\n#{topics_list}\n""
      end

      def intents_section
        return """" if @intents.empty?

        intents_list = @intents.map { |i| ""- #{i[:intent]} (#{i[:start]} - #{i[:end]})"" }.join(""\n"")
        ""\nDetected Intents:\n#{intents_list}\n""
      end
    end
  end
end",false
deepgram_topics_generator.rb,/lib/ComputerTools/generators/deepgram/,"# frozen_string_literal: true

module ComputerTools
  module Generators
    class DeepgramTopicsGenerator < Sublayer::Generators::Base
      llm_output_adapter type: :list_of_strings,
                         name:        ""topics"",
                         description: ""Enhanced topic extraction and categorization""

      def initialize(transcript:, existing_topics: [])
        @transcript = transcript
        @existing_topics = existing_topics
      end

      def generate
        super
      end

      def prompt
        <<-PROMPT
          Analyze this transcript and extract comprehensive topic information.

          Transcript:
          #{@transcript}

          #{existing_topics_section}

          Please identify and categorize topics with the following approach:

          ## Topic Extraction Goals:
          1. **Primary Topics**: Main subjects of discussion
          2. **Subtopics**: Detailed aspects within primary topics
          3. **Technical Topics**: Technical concepts, tools, or processes mentioned
          4. **Business Topics**: Business-related discussions, decisions, strategies
          5. **Contextual Topics**: Environmental or situational topics
          6. **Emerging Topics**: New or unexpected subjects that arise

          ## Topic Categories:
          - Business & Strategy
          - Technical & Engineering
          - Process & Operations
          - Communication & Collaboration
          - Problem Solving & Issues
          - Planning & Decision Making
          - Education & Knowledge Transfer
          - Innovation & Ideas

          ## Instructions:
          - Provide specific, actionable topic names
          - Avoid overly generic terms
          - Include technical terminology where appropriate
          - Consider both explicit and implicit topics
          - Maintain consistent naming conventions
          - Order by relevance and importance

          Return a list of enhanced topics that provide better insight than basic keyword extraction.
          Each topic should be clear, specific, and valuable for categorization and search.
        PROMPT
      end

      private

      def existing_topics_section
        return """" if @existing_topics.empty?

        topics_list = @existing_topics.map { |t| ""- #{t[:topic]}"" }.join(""\n"")
        ""\nExisting Topics Detected by Deepgram:\n#{topics_list}\n""
      end
    end
  end
end",false
file_activity_report_generator.rb,/lib/ComputerTools/generators/file_activity/,"# frozen_string_literal: true

module ComputerTools
  module Generators
    class FileActivityReportGenerator < Sublayer::Generators::Base
      def initialize(data:, config:, format: :table, interactive: false, time_range: '24h')
        @data = data
        @format = format
        @interactive = interactive
        @time_range = time_range
        @config = config
      end

      def call
        case @format
        when :json
          generate_json_report
        when :summary
          generate_summary_report
        when :table
          generate_table_report
        else
          generate_table_report
        end

        handle_interactive_mode if @interactive
        true
      rescue StandardError => e
        puts ""‚ùå Error generating report: #{e.message}"".colorize(:red)
        false
      end

      private

      def generate_json_report
        report_data = {
          metadata: {
            generated_at: Time.now.iso8601,
            time_range: @time_range,
            total_files: @data.length
          },
          summary: generate_summary_stats,
          files: @data
        }

        puts JSON.pretty_generate(report_data)
      end

      def generate_summary_report
        stats = generate_summary_stats

        puts ""\n#{'=' * 60}""
        puts ""üìä FILE ACTIVITY SUMMARY (#{@time_range})"".colorize(:blue)
        puts ""="" * 60

        puts ""üìÅ Total files analyzed: #{stats[:total_files]}"".colorize(:green)
        puts ""‚è∞ Active time periods: #{stats[:hours_with_activity]}"".colorize(:cyan)
        puts ""üîÑ Modified files: #{stats[:modified_files]}"".colorize(:yellow)

        puts ""\nüìà By tracking method:"".colorize(:blue)
        stats[:by_tracking].each do |method, count|
          puts ""  #{method}: #{count}"".colorize(:cyan)
        end

        puts ""\nüìù Change statistics:"".colorize(:blue)
        puts ""  + Lines added: #{stats[:total_additions]}"".colorize(:green)
        puts ""  - Lines removed: #{stats[:total_deletions]}"".colorize(:red)
        puts ""  üì¶ Total chunks: #{stats[:total_chunks]}"".colorize(:cyan)

        return unless stats[:top_files].any?

        puts ""\nüî• Most active files:"".colorize(:blue)
        stats[:top_files].first(5).each_with_index do |file_data, i|
          changes = file_data[:additions] + file_data[:deletions]
          puts ""  #{i + 1}. #{file_data[:file]} (#{changes} changes)"".colorize(:cyan)
        end
      end

      def generate_table_report
        return puts ""üì≠ No files to display."".colorize(:cyan) if @data.empty?

        grouped_data = group_files_by_hour(@data)

        display_overall_summary

        grouped_data.keys.sort.each do |hour_key|
          hour_data = grouped_data[hour_key]
          display_hourly_table(hour_key, hour_data)
        end
      end

      def display_overall_summary
        stats = generate_summary_stats

        puts ""\n#{'=' * 80}""
        puts ""üìä OVERALL SUMMARY - File Activity Analysis (#{@time_range})"".colorize(:blue)
        puts ""="" * 80

        puts ""üìÅ Total files: #{stats[:total_files]}"".colorize(:green)
        puts ""‚è∞ Hours with activity: #{stats[:hours_with_activity]}"".colorize(:cyan)
        puts ""üîÑ Modified files: #{stats[:modified_files]}"".colorize(:yellow)

        stats[:by_tracking].each do |method, count|
          puts ""üìä #{method} tracked: #{count}"".colorize(:cyan)
        end

        puts ""üìà Total additions: #{stats[:total_additions]}"".colorize(:green)
        puts ""üìâ Total deletions: #{stats[:total_deletions]}"".colorize(:red)
      end

      def display_hourly_table(hour_key, hour_data)
        hour_label = format_hour_label(hour_key)

        puts ""\n#{'=' * 80}""
        puts ""üìÖ Files Modified During: #{hour_label}"".colorize(:blue)
        puts ""="" * 80

        display_data_table(hour_data, hour_label)
      end

      def display_data_table(data, _title)
        return puts ""üì≠ No files found."".colorize(:cyan) if data.empty?

        # Define headers and columns
        columns = %i[file modified size tracking git_status index worktree additions deletions chunks]
        headers = [
          ""File Path"",
          ""Modified"",
          ""Size"",
          ""Tracking"",
          ""Status"",
          ""Index"",
          ""Worktree"",
          ""+Lines"",
          ""-Lines"",
          ""Chunks""
        ]

        # Convert hash data to row arrays with row numbers
        rows = data.map.with_index(1) do |row_data, index|
          row_values = columns.map { |col| format_cell_value(row_data[col], col) }
          [index] + row_values # Add row number as first column
        end

        # Create table with row numbers header
        table_headers = [""#""] + headers
        table = TTY::Table.new(header: table_headers, rows: rows)

        # Render table with styling
        puts table.render(:ascii) do |renderer|
          renderer.border.separator = :each_row
          renderer.padding = [0, 1, 0, 1]
          renderer.alignments = [:right] + ([:left] * headers.length)
        end

        display_hour_summary(data)
      end

      def format_cell_value(value, column)
        case column
        when :additions
          value.to_s.colorize(:green)
        when :deletions
          value.to_s.colorize(:red)
        when :git_status
          value == '--' ? value : value.colorize(:yellow)
        when :tracking
          case value
          when 'Git'
            value.colorize(:blue)
          when 'YADM'
            value.colorize(:magenta)
          when 'Restic'
            value.colorize(:cyan)
          else
            value.to_s
          end
        else
          value.to_s
        end
      end

      def display_hour_summary(data)
        tracking_counts = data.group_by { |row| row[:tracking] }.transform_values(&:count)
        modified_files = data.count { |row| row[:git_status] != '--' }
        total_additions = data.sum { |row| row[:additions] }
        total_deletions = data.sum { |row| row[:deletions] }

        puts ""\nüìä Hour Summary:"".colorize(:blue)
        puts ""  üìÅ Files: #{data.length}"".colorize(:cyan)
        puts ""  üîÑ Modified: #{modified_files}"".colorize(:yellow)

        tracking_counts.each do |method, count|
          puts ""  üìä #{method}: #{count}"".colorize(:cyan)
        end

        puts ""  üìà Additions: #{total_additions}, üìâ Deletions: #{total_deletions}"".colorize(:green)
      end

      def handle_interactive_mode
        return unless @interactive

        puts ""\nüéØ Interactive Mode - Choose an action:"".colorize(:blue)
        puts ""  1. View detailed file analysis"".colorize(:cyan)
        puts ""  2. Export data to JSON"".colorize(:cyan)
        puts ""  3. Filter by tracking method"".colorize(:cyan)
        puts ""  4. Exit"".colorize(:cyan)

        print ""\nEnter your choice (1-4): "".colorize(:yellow)
        choice = gets.chomp.to_i

        case choice
        when 1
          interactive_file_details
        when 2
          interactive_export_json
        when 3
          interactive_filter_tracking
        when 4
          puts ""üëã Goodbye!"".colorize(:green)
        else
          puts ""‚ùå Invalid choice. Exiting."".colorize(:red)
        end
      end

      def interactive_file_details
        puts ""\nüìã Select a file for detailed analysis:"".colorize(:blue)

        @data.each_with_index do |file_data, index|
          status_indicator = file_data[:git_status] == '--' ? 'üìÑ' : 'üîÑ'
          puts ""  #{index + 1}. #{status_indicator} #{file_data[:file]}"".colorize(:cyan)
        end

        print ""\nEnter file number: "".colorize(:yellow)
        file_index = gets.chomp.to_i - 1

        if file_index >= 0 && file_index < @data.length
          display_file_details(@data[file_index])
        else
          puts ""‚ùå Invalid file number."".colorize(:red)
        end
      end

      def display_file_details(file_data)
        puts ""\n#{'=' * 60}""
        puts ""üìÑ FILE DETAILS"".colorize(:blue)
        puts ""="" * 60

        file_data.each do |key, value|
          formatted_key = key.to_s.capitalize.tr('_', ' ')
          puts ""#{formatted_key}: #{value}"".colorize(:cyan)
        end
      end

      def interactive_export_json
        puts ""\nüíæ Exporting data to JSON format..."".colorize(:blue)
        generate_json_report
        puts ""\n‚úÖ JSON export completed."".colorize(:green)
      end

      def interactive_filter_tracking
        tracking_methods = @data.map { |d| d[:tracking] }.uniq.sort

        puts ""\nüìä Filter by tracking method:"".colorize(:blue)
        tracking_methods.each_with_index do |method, index|
          count = @data.count { |d| d[:tracking] == method }
          puts ""  #{index + 1}. #{method} (#{count} files)"".colorize(:cyan)
        end

        print ""\nEnter tracking method number: "".colorize(:yellow)
        method_index = gets.chomp.to_i - 1

        if method_index >= 0 && method_index < tracking_methods.length
          method = tracking_methods[method_index]
          filtered_data = @data.select { |d| d[:tracking] == method }
          puts ""\nüìã Files tracked by #{method}:"".colorize(:blue)
          display_data_table(filtered_data, ""#{method} Files"")
        else
          puts ""‚ùå Invalid tracking method number."".colorize(:red)
        end
      end

      def generate_summary_stats
        tracking_counts = @data.group_by { |row| row[:tracking] }.transform_values(&:count)
        modified_files = @data.count { |row| row[:git_status] != '--' }
        total_additions = @data.sum { |row| row[:additions] }
        total_deletions = @data.sum { |row| row[:deletions] }
        total_chunks = @data.sum { |row| row[:chunks] }
        hours_with_activity = group_files_by_hour(@data).keys.count

        # Top files by activity
        top_files = @data.sort_by { |d| -(d[:additions] + d[:deletions]) }

        {
          total_files: @data.length,
          hours_with_activity: hours_with_activity,
          modified_files: modified_files,
          by_tracking: tracking_counts,
          total_additions: total_additions,
          total_deletions: total_deletions,
          total_chunks: total_chunks,
          top_files: top_files
        }
      end

      def group_files_by_hour(data)
        data.group_by do |row|
          row[:modified_time].strftime('%Y-%m-%d %H')
        end
      end

      def format_hour_label(hour_key)
        date_time = Time.strptime(hour_key, '%Y-%m-%d %H')
        date_time.strftime('%A, %B %d, %Y at %I:%M %p - %I:59 %p')
      rescue ArgumentError
        hour_key
      end
    end
  end
end",false
overview_generator.rb,/lib/ComputerTools/generators/,"# frozen_string_literal: true

# Sublayer.configuration.ai_provider = Sublayer::Providers::Ollama

module ComputerTools
  module Generators
    class OverviewGenerator < Sublayer::Generators::Base
      llm_output_adapter type: :single_string,
                         name: ""generated_text"",
                         description: ""A comprehensive overview of ComputerTools features and functionality""

      def initialize(format: 'console')
        @format = format
      end

      def prompt
        <<-PROMPT
          Generate a comprehensive overview of ComputerTools based on the following documentation.
          Format the output as #{@format} format.

          CONTEXT INFORMATION:
          ComputerTools is a comprehensive Ruby CLI toolkit built on the Sublayer framework, providing AI-enhanced tools for software development and automation. It's a modular collection of intelligent CLI utilities that leverage AI capabilities through the Sublayer framework.

          AVAILABLE TOOLS:

          1. BLUEPRINT MANAGER:
          - AI-enhanced code blueprint management with semantic search and automatic metadata generation
          - Features: AI-generated metadata, semantic search, direct database access, smart editing, export/import, safe deletion, interactive UI
          - Uses PostgreSQL with pgvector extension for vector embeddings
          - Integrates with Rails server for web interface
          - Commands: submit, list, browse, view, edit, search, export, delete, config

          2. DEEPGRAM PARSER:
          - Parse, analyze, and convert Deepgram JSON output with AI-enhanced insights
          - Features: Multi-format output (markdown, SRT, JSON, summary), interactive analysis, AI integration, statistics & metrics
          - Commands: parse, convert, analyze, config
          - Output formats: markdown (rich analysis), SRT (subtitles), JSON (structured data), summary (concise overview)

          3. LATEST CHANGES ANALYZER:
          - Comprehensive file activity tracking across Git, YADM, and Restic with intelligent analysis
          - Features: Multi-platform file tracking, intelligent analysis, multiple output formats, advanced configuration
          - Tracks: Git repositories, YADM dotfiles, Restic backups, untracked files
          - Commands: analyze, config
          - Output formats: table view, summary view, JSON export, interactive mode

          4. INTERACTIVE MENU SYSTEM:
          - User-friendly interactive menu system for command discovery and execution
          - Features: guided parameter collection, seamless navigation, error handling, debug mode
          - Provides alternative to traditional CLI usage

          KEY FEATURES:
          - AI-Powered Intelligence: Automatic metadata generation, semantic search, improvement suggestions
          - Developer Experience: Interactive CLI, multiple output formats, flexible configuration
          - Performance & Reliability: Direct database access, vector embeddings, connection pooling
          - Modular Architecture: Commands, Actions, Generators, Wrappers pattern
          - Framework Integration: Built on Thor CLI framework with Sublayer AI integration

          ARCHITECTURE:
          - Command Pattern: CLI commands with clear interfaces
          - Action Pattern: Encapsulated business logic
          - Generator Pattern: AI-powered content generation
          - Wrapper Pattern: External tool integration
          - Configuration: YAML-based with environment variables

          USAGE MODES:
          - Interactive Mode: ./exe/ComputerTools (launches menu)
          - Command Line Mode: ./exe/ComputerTools <command> <subcommand> [options]

          Generate an engaging overview that highlights the comprehensive nature of ComputerTools, its AI-powered capabilities, and practical applications for developers. Include key benefits, primary tools, and usage examples.

          For console format: Use colorized output with emojis and clear sections
          For markdown format: Use proper markdown structure with headers, lists, and code blocks
          For JSON format: Provide structured data with nested objects for each tool
        PROMPT
      end
    end
  end
end",false
logger.rb,/lib/ComputerTools/,"# frozen_string_literal: true

module ComputerTools
  # Centralized logger module for the ComputerTools application.
  # Encapsulates TTY::Logger configuration and provides a singleton instance.
  module Logger
    # Class variable to hold the singleton logger instance.
    @@instance = nil

    # Retrieves the singleton logger instance.
    # On first call, it initializes and configures the logger.
    #
    # @return [TTY::Logger] The configured logger instance.
    def self.instance
      return @@instance if @@instance

      # Load user configuration for the logger
      app_config = ComputerTools::Configuration.new
      log_level = app_config.fetch(:logger, :level)&.to_sym || :info
      file_logging_enabled = app_config.fetch(:logger, :file_logging) || false
      log_file_path = app_config.fetch(:logger, :file_path) || default_log_path
      file_log_level = app_config.fetch(:logger, :file_level)&.to_sym || :debug

      @@instance = TTY::Logger.new do |config|
        # Configure handlers (console and optional file)
        handlers = []
        handlers << configure_console_handler(log_level)
        handlers << configure_file_handler(log_file_path, file_log_level) if file_logging_enabled

        config.handlers = handlers
      end

      # Add custom log types after initialization with styling
      # Use try-catch to handle any conflicts with built-in types
      begin
        @@instance.add_type(:success, { level: :info, symbol: '‚úÖ', color: :green })
      rescue TTY::Logger::Error
        # Type already exists, skip
      end

      begin
        @@instance.add_type(:failure, { level: :error, symbol: '‚ùå', color: :red })
      rescue TTY::Logger::Error
        # Type already exists, skip
      end

      begin
        @@instance.add_type(:tip, { level: :info, symbol: 'üí°', color: :cyan })
      rescue TTY::Logger::Error
        # Type already exists, skip
      end

      begin
        @@instance.add_type(:step, { level: :info, symbol: 'üöÄ', color: :blue })
      rescue TTY::Logger::Error
        # Type already exists, skip
      end

      @@instance
    end

    # Reset the singleton instance (useful for testing)
    def self.reset!
      @@instance = nil
    end

    private

    # Configures the console handler with custom styles.
    #
    # @param level [Symbol] The minimum log level for the console.
    # @return [Array] The handler configuration array for TTY::Logger.
    def self.configure_console_handler(level)
      [
        :console,
        {
          level: level,
          output: $stderr, # Log to stderr to separate from program output
          styles: {
            info:  { symbol: '‚ÑπÔ∏è', color: :blue },
            debug: { symbol: 'üêû', color: :magenta },
            error: { symbol: '‚ùå', color: :red },
            warn:  { symbol: '‚ö†Ô∏è', color: :yellow },
            fatal: { symbol: 'üíÄ', color: :red, bold: true }
          }
        }
      ]
    end

    # Configures the file stream handler.
    #
    # @param path [String] The path to the log file.
    # @param level [Symbol] The minimum log level for the file.
    # @return [Array] The handler configuration array for TTY::Logger.
    def self.configure_file_handler(path, level)
      # Ensure the directory for the log file exists
      FileUtils.mkdir_p(File.dirname(path))

      [
        :stream,
        {
          level: level,
          output: File.open(path, 'a'),
          formatter: :json # Use JSON format for structured logging
        }
      ]
    end

    # Determines the default path for the log file.
    #
    # @return [String] The absolute path for the log file.
    def self.default_log_path
      # Use XDG Base Directory Specification if available, otherwise fallback
      state_home = ENV['XDG_STATE_HOME'] || File.expand_path('~/.local/state')
      File.join(state_home, 'computertools', 'app.log')
    end
  end
end",false
ollama.rb,/lib/ComputerTools/providers/sublayer/,"# frozen_string_literal: true

module Sublayer
  module Providers
    class Ollama
      def self.call(host:, model:, prompt:, output_adapter:)
        response = HTTParty.post(
          ""#{host}"",
          body: {
            model: '#{model}',
            messages: [
              {
                role: ""user"",
                content: prompt
              }
            ],
            stream: false,
            tools: [
              {
                type: ""function"",
                function: {
                  name: 'response',
                  parameters: {
                    type: ""object"",
                    properties: output_adapter.format_properties,
                    required: output_adapter.format_required
                  }
                }
              }
            ]
          }.to_json
        )

        message = response['message']

        raise ""No function called"" unless message[""tool_calls""].length > 0

        function_body = message.dig(""tool_calls"", 0, ""function"", ""arguments"")
        function_body[output_adapter.name]
      end
    end
  end
end",false
openrouter.rb,/lib/ComputerTools/providers/sublayer/,"#!/usr/bin/env ruby
# frozen_string_literal: true

module Sublayer
  module Providers
    class OpenRouter
      def self.call(prompt:, output_adapter:)
        client = ::OpenAI::Client.new(access_token: ENV.fetch('OPENAI_ACCESS_TOKEN'), uri_base: 'https://openrouter.ai/api/v1')

        request_id = SecureRandom.uuid

        Sublayer.configuration.logger.log(
          :info, 'OpenRouter API request', {
            model: Sublayer.configuration.ai_model,
            prompt:     prompt,
            request_id: request_id
          }
        )

        before_request = Time.now

        response = client.chat(
          parameters: {
            model: Sublayer.configuration.ai_model,
            messages: [
              {
                role: 'user',
                content: prompt
              }
            ],
            tool_choice: { type: 'function', function: { name: output_adapter.name } },
            tools: [
              {
                type: 'function',
                function: {
                  name: output_adapter.name,
                  description: output_adapter.description,
                  parameters: {
                    type: 'object',
                    properties: output_adapter.format_properties
                  },
                  required: output_adapter.format_required
                }
              }
            ]
          }
        )

        after_request = Time.now
        response_time = after_request - before_request

        Sublayer.configuration.logger.log(
          :info, 'OpenRouter API response', {
            request_id: request_id,
            response_time: response_time,
            usage:         {
              input_tokens: response['usage']['prompt_tokens'],
              output_tokens: response['usage']['completion_tokens'],
              total_tokens:  response['usage']['total_tokens']
            }
          }
        )

        message = response.dig('choices', 0, 'message')

        raise 'No function called' unless message['tool_calls']

        function_body = message.dig('tool_calls', 0, 'function', 'arguments')

        if function_body == '{}'
          raise ""Error generating with OpenRouter. Empty response. Try rewording your output adapter params to be from the perspective of the model. Full Response: #{response}""
        end
        if response['choices'][0]['finish_reason'] == 'length'
          raise 'Error generating with OpenRouter. Error: Max tokens exceeded. Try breaking your problem up into smaller pieces.'
        end

        results = JSON.parse(function_body)[output_adapter.name]
      end
    end
  end
end",false
blueprint_database.rb,/lib/ComputerTools/wrappers/,"# frozen_string_literal: true

module ComputerTools
  module Wrappers
    #
    # Provides a direct database interface for managing ""blueprints"" (code snippets).
    #
    # This class encapsulates all database operations for blueprints, including
    # standard CRUD actions, category management, and advanced vector-based
    # similarity searches. It uses the Sequel ORM to interact with a PostgreSQL
    # database (requiring the `pgvector` extension for search) and leverages the
    # Google Gemini API to generate text embeddings for semantic search capabilities.
    #
    # Configuration is loaded from `config/blueprints.yml`, environment variables
    # (`BLUEPRINT_DATABASE_URL`, `GEMINI_API_KEY`), or sensible defaults.
    #
    class BlueprintDatabase
      # The Google Gemini model used for generating text embeddings.
      EMBEDDING_MODEL = 'text-embedding-004'
      # The number of dimensions for the text embedding vectors.
      EMBEDDING_DIMENSIONS = 768

      # @!attribute [r] db
      #   @return [Sequel::Database] The active Sequel database connection instance.
      attr_reader :db

      #
      # Initializes the database connection and validates the schema.
      #
      # Connects to the PostgreSQL database using a URL determined by the provided
      # parameter, a configuration file, or environment variables. It also ensures
      # that the necessary tables (`blueprints`, `categories`, `blueprints_categories`)
      # and the `pgvector` extension exist.
      #
      # @param database_url [String, nil] The PostgreSQL connection URL. If nil,
      #   it falls back to `BLUEPRINT_DATABASE_URL` or `DATABASE_URL`
      #   environment variables, or a default local URL.
      #
      # @raise [StandardError] If the database connection fails or a required
      #   table is missing from the schema.
      #
      def initialize(database_url: nil)
        @database_url = database_url || load_database_url
        @db = connect_to_database
        @gemini_api_key = load_gemini_api_key

        validate_database_schema
      end

      #
      # Creates a new blueprint, generates its embedding, and associates categories.
      #
      # This method inserts a new blueprint into the database within a transaction.
      # It automatically generates a vector embedding from the blueprint's name and
      # description using the Gemini API. If categories are provided, they are
      # created if they don't exist and linked to the new blueprint.
      #
      # @param code [String] The code content for the blueprint.
      # @param name [String, nil] A name for the blueprint.
      # @param description [String, nil] A description of the blueprint's purpose.
      # @param categories [Array<String>] A list of category names to associate.
      #
      # @return [Hash, nil] A hash representing the complete blueprint record
      #   (including its new ID and categories), or `nil` if an error occurs.
      #
      # @example
      #   db.create_blueprint(
      #     code: ""puts 'Hello, World!'"",
      #     name: ""Hello World Snippet"",
      #     description: ""A simple Ruby script to print a greeting."",
      #     categories: [""Ruby"", ""Examples""]
      #   )
      #   # => {id: 1, code: ""..."", name: ""..."", ..., categories: [{id: 1, title: ""Ruby""}, ...]}
      #
      def create_blueprint(code:, name: nil, description: nil, categories: [])
        @db.transaction do
          # Insert blueprint record
          blueprint_id = @db[:blueprints].insert(
            code: code,
            name: name,
            description: description,
            embedding: generate_embedding(name: name, description: description),
            created_at: Time.now,
            updated_at: Time.now
          )

          # Handle categories if provided
          insert_blueprint_categories(blueprint_id, categories) if categories.any?

          # Return the created blueprint
          get_blueprint(blueprint_id)
        end
      rescue StandardError => e
        puts ""‚ùå Error creating blueprint: #{e.message}"".colorize(:red)
        nil
      end

      #
      # Retrieves a specific blueprint and its associated categories by ID.
      #
      # @param id [Integer] The unique identifier of the blueprint.
      #
      # @return [Hash, nil] A hash containing the blueprint's data and a nested
      #   `:categories` array, or `nil` if no blueprint with that ID is found.
      #
      # @example
      #   blueprint = db.get_blueprint(42)
      #   # => {id: 42, name: ""My Blueprint"", ..., categories: [...]}
      #
      def get_blueprint(id)
        blueprint = @db[:blueprints].where(id: id).first
        return nil unless blueprint

        # Add categories
        blueprint[:categories] = get_blueprint_categories(id)
        blueprint
      end

      #
      # Lists all blueprints with pagination, ordered by creation date.
      #
      # Retrieves a collection of blueprints, with the most recently created ones
      # appearing first. Each blueprint in the returned array includes its
      # associated categories.
      #
      # @param limit [Integer] The maximum number of blueprints to return.
      # @param offset [Integer] The number of blueprints to skip, for pagination.
      #
      # @return [Array<Hash>] An array of blueprint hashes.
      #
      # @example
      #   # Get the 10 most recent blueprints
      #   recent_blueprints = db.list_blueprints(limit: 10)
      #
      #   # Get the next page of 10 blueprints
      #   next_page = db.list_blueprints(limit: 10, offset: 10)
      #
      def list_blueprints(limit: 100, offset: 0)
        blueprints = @db[:blueprints]
          .order(Sequel.desc(:created_at))
          .limit(limit)
          .offset(offset)
          .all

        # Add categories for each blueprint
        blueprints.each do |blueprint|
          blueprint[:categories] = get_blueprint_categories(blueprint[:id])
        end

        blueprints
      end

      #
      # Searches for blueprints by semantic similarity to a query string.
      #
      # This method generates a vector embedding for the `query` text and uses
      # `pgvector`'s cosine distance operator (`<->`) to find the most semantically
      # similar blueprints in the database. Results are ordered by similarity.
      #
      # @param query [String] The search query text.
      # @param limit [Integer] The maximum number of search results to return.
      #
      # @return [Array<Hash>] An array of blueprint hashes, sorted by relevance.
      #   Each hash includes a `:distance` key indicating similarity (lower is better).
      #   Returns an empty array if query embedding fails.
      #
      # @example
      #   results = db.search_blueprints(query: ""http server in ruby"", limit: 5)
      #   # => [{id: 12, ..., distance: 0.18}, {id: 34, ..., distance: 0.21}]
      #
      def search_blueprints(query:, limit: 10)
        # Generate embedding for the search query
        query_embedding = generate_embedding_for_text(query)
        return [] unless query_embedding

        # Perform vector similarity search using pgvector
        results = @db.fetch(
          ""SELECT *, embedding <-> ? AS distance
           FROM blueprints
           ORDER BY embedding <-> ?
           LIMIT ?"",
          query_embedding, query_embedding, limit
        ).all

        # Add categories for each result
        results.each do |blueprint|
          blueprint[:categories] = get_blueprint_categories(blueprint[:id])
        end

        results
      end

      #
      # Deletes a blueprint and its category associations from the database.
      #
      # The deletion is performed in a transaction to ensure atomicity. It first
      # removes links in the `blueprints_categories` join table before deleting
      # the main blueprint record.
      #
      # @param id [Integer] The ID of the blueprint to delete.
      #
      # @return [Boolean] `true` if a record was successfully deleted, `false`
      #   otherwise (e.g., if the ID did not exist or an error occurred).
      #
      def delete_blueprint(id)
        @db.transaction do
          # Delete category associations
          @db[:blueprints_categories].where(blueprint_id: id).delete

          # Delete the blueprint
          deleted_count = @db[:blueprints].where(id: id).delete
          deleted_count > 0
        end
      rescue StandardError => e
        puts ""‚ùå Error deleting blueprint: #{e.message}"".colorize(:red)
        false
      end

      #
      # Updates the attributes of an existing blueprint.
      #
      # This method updates a blueprint's data in a transaction. If `name` or
      # `description` are changed, the embedding vector is automatically
      # regenerated. If a `categories` array is provided, it will **replace**
      # all existing category associations for the blueprint.
      #
      # @param id [Integer] The ID of the blueprint to update.
      # @param code [String, nil] The new code content.
      # @param name [String, nil] The new name.
      # @param description [String, nil] The new description.
      # @param categories [Array<String>, nil] An array of category names to
      #   set for the blueprint, replacing any existing ones.
      #
      # @return [Hash, nil] The updated blueprint hash, or `nil` on failure.
      #
      def update_blueprint(id:, code: nil, name: nil, description: nil, categories: nil)
        updates = { updated_at: Time.now }
        updates[:code] = code if code
        updates[:name] = name if name
        updates[:description] = description if description

        # Regenerate embedding if name or description changed
        if name || description
          current = get_blueprint(id)
          new_name = name || current[:name]
          new_description = description || current[:description]
          updates[:embedding] = generate_embedding(name: new_name, description: new_description)
        end

        @db.transaction do
          # Update blueprint
          @db[:blueprints].where(id: id).update(updates)

          # Update categories if provided
          if categories
            @db[:blueprints_categories].where(blueprint_id: id).delete
            insert_blueprint_categories(id, categories)
          end

          # Return updated blueprint
          get_blueprint(id)
        end
      rescue StandardError => e
        puts ""‚ùå Error updating blueprint: #{e.message}"".colorize(:red)
        nil
      end

      #
      # Retrieves all available categories from the database.
      #
      # @return [Array<Hash>] An array of hashes, where each hash represents a category.
      #
      def get_categories
        @db[:categories].all
      end

      #
      # Creates a new category or finds an existing one by title.
      #
      # If a category with the given title already exists, this method will not
      # create a duplicate. Instead, it will find and return the ID of the
      # existing category.
      #
      # @param title [String] The unique title for the category.
      # @param description [String, nil] An optional description for the category.
      #
      # @return [Integer] The ID of the created or existing category.
      #
      def create_category(title:, description: nil)
        @db[:categories].insert(
          title: title,
          created_at: Time.now,
          updated_at: Time.now
        )
      rescue Sequel::UniqueConstraintViolation
        # Category already exists, find and return it
        @db[:categories].where(title: title).first[:id]
      end

      #
      # Gathers basic statistics about the blueprints database.
      #
      # Provides a quick summary, including total counts of blueprints and
      # categories, and the database URL (with the password redacted).
      #
      # @return [Hash{Symbol => Object}] A hash with `:total_blueprints`,
      #   `:total_categories`, and `:database_url` keys.
      #
      def stats
        {
          total_blueprints: @db[:blueprints].count,
          total_categories: @db[:categories].count,
          database_url: @database_url.gsub(/:[^:@]*@/, ':***@') # Hide password
        }
      end

      private

      #
      # Loads the database URL from a config file or environment variables.
      #
      # @!visibility private
      # @return [String] The database connection URL.
      #
      def load_database_url
        # Check configuration file first
        config_file = File.join(__dir__, '..', 'config', 'blueprints.yml')
        if File.exist?(config_file)
          config = YAML.load_file(config_file)
          return config['database']['url'] if config['database']&.[]('url')
        end

        # Fall back to environment variables
        ENV['BLUEPRINT_DATABASE_URL'] ||
          ENV['DATABASE_URL'] ||
          'postgres://localhost/blueprints_development'
      end

      #
      # Loads the Gemini API key from environment variables.
      #
      # @!visibility private
      # @return [String, nil] The API key.
      #
      def load_gemini_api_key
        ENV['GEMINI_API_KEY'] || ENV.fetch('GOOGLE_API_KEY', nil)
      end

      #
      # Establishes a connection to the database using Sequel.
      #
      # @!visibility private
      # @return [Sequel::Database] The database connection object.
      # @raise [StandardError] If the connection fails.
      #
      def connect_to_database
        Sequel.connect(@database_url)
      rescue StandardError => e
        puts ""‚ùå Failed to connect to database: #{e.message}"".colorize(:red)
        puts ""Database URL: #{@database_url.gsub(/:[^:@]*@/, ':***@')}"".colorize(:yellow)
        raise e
      end

      #
      # Validates that the required database tables and extensions exist.
      #
      # @!visibility private
      # @raise [StandardError] If a required table is not found.
      #
      def validate_database_schema
        required_tables = %i[blueprints categories blueprints_categories]

        required_tables.each do |table|
          unless @db.table_exists?(table)
            raise ""Missing required table: #{table}. Please ensure the blueprints database is properly set up.""
          end
        end

        # Check for vector extension
        return if @db.fetch(""SELECT 1 FROM pg_extension WHERE extname = 'vector'"").first

        puts ""‚ö†Ô∏è  Warning: pgvector extension not found. Vector search may not work."".colorize(:yellow)
      end

      #
      # Generates an embedding vector for a name and description combination.
      #
      # @!visibility private
      # @param name [String] The name of the blueprint.
      # @param description [String] The description of the blueprint.
      # @return [String, nil] A string representation of the vector `""[d1,d2,...]""`.
      #
      def generate_embedding(name:, description:)
        content = { name: name, description: description }.to_json
        generate_embedding_for_text(content)
      end

      #
      # Generates an embedding vector for arbitrary text using the Google Gemini API.
      #
      # @!visibility private
      # @param text [String] The text to embed.
      # @return [String, nil] A string representation of the vector `""[d1,d2,...]""`,
      #   or `nil` if the API call fails or a key is missing.
      #
      def generate_embedding_for_text(text)
        unless @gemini_api_key
          puts ""‚ö†Ô∏è  Warning: No Gemini API key found. Skipping embedding generation."".colorize(:yellow)
          return nil
        end

        uri = URI(""https://generativelanguage.googleapis.com/v1beta/models/#{EMBEDDING_MODEL}:embedContent"")
        uri.query = URI.encode_www_form(key: @gemini_api_key)

        request = Net::HTTP::Post.new(uri)
        request['Content-Type'] = 'application/json'
        request.body = {
          model: ""models/#{EMBEDDING_MODEL}"",
          content: {
            parts: [{ text: text }]
          }
        }.to_json

        response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
          http.request(request)
        end

        if response.code == '200'
          data = JSON.parse(response.body)
          embedding = data.dig('embedding', 'values')

          if embedding && embedding.length == EMBEDDING_DIMENSIONS
            ""[#{embedding.join(',')}]"" # Format as PostgreSQL vector
          else
            puts ""‚ö†Ô∏è  Warning: Invalid embedding dimensions received"".colorize(:yellow)
            nil
          end
        else
          puts ""‚ùå Error generating embedding: #{response.code} #{response.message}"".colorize(:red)
          puts response.body if ENV['DEBUG']
          nil
        end
      rescue StandardError => e
        puts ""‚ùå Error calling Gemini API: #{e.message}"".colorize(:red)
        nil
      end

      #
      # Fetches all categories associated with a given blueprint ID.
      #
      # @!visibility private
      # @param blueprint_id [Integer] The blueprint's ID.
      # @return [Array<Hash>] An array of category hashes.
      #
      def get_blueprint_categories(blueprint_id)
        @db.fetch(
          ""SELECT c.* FROM categories c
           JOIN blueprints_categories bc ON c.id = bc.category_id
           WHERE bc.blueprint_id = ?"",
          blueprint_id
        ).all
      end

      #
      # Associates a list of categories with a blueprint.
      #
      # For each category name, it finds or creates the category record and then
      # creates a link in the `blueprints_categories` join table.
      #
      # @!visibility private
      # @param blueprint_id [Integer] The ID of the blueprint to link.
      # @param category_names [Array<String>] The names of the categories to link.
      #
      def insert_blueprint_categories(blueprint_id, category_names)
        category_names.each do |category_name|
          category_name = category_name.strip
          next if category_name.empty?

          # Find or create category
          category = @db[:categories].where(title: category_name).first
          category_id = if category
                          category[:id]
                        else
                          create_category(title: category_name)
                        end

          # Link blueprint to category
          @db[:blueprints_categories].insert_ignore.insert(
            blueprint_id: blueprint_id,
            category_id: category_id
          )
        end
      end
    end
  end
end",false
deepgram_analyzer.rb,/lib/ComputerTools/wrappers/,"# frozen_string_literal: true

module ComputerTools
  module Wrappers
    class DeepgramAnalyzer
      FIELD_MAPPING = {
        ""Segment Identifier"" => ""segment_id"",
        ""Start Time of Segment"" => ""start_time"",
        ""End Time of Segment"" => ""end_time"",
        ""Segment Transcript"" => ""transcript"",
        ""Segment Topic"" => ""topic"",
        ""Relevant Keywords"" => ""keywords"",
        ""AI Analysis of Segment"" => ""gemini_analysis"",
        ""Software Detected in Segment"" => ""software_detected"",
        ""List of Software Detections"" => ""software_detections""
      }.freeze

      attr_reader :segments, :available_fields

      def initialize(json_file_path)
        raise ArgumentError, ""File not found: #{json_file_path}"" unless File.exist?(json_file_path)

        @json_file_path = json_file_path
        @segments = load_segments_data(json_file_path)
        @available_fields = detect_available_fields
      rescue JSON::ParserError => e
        raise ""Invalid JSON file: #{e.message}""
      end

      def extract_fields(selected_fields)
        results = []

        @segments.each do |segment|
          segment_data = {}

          selected_fields.each do |field_name|
            json_key = FIELD_MAPPING[field_name]
            next unless json_key

            value = segment[json_key]
            next if value.nil?

            # Format arrays nicely
            formatted_value = value.is_a?(Array) ? value.join("", "") : value
            segment_data[field_name] = formatted_value
          end

          results << segment_data unless segment_data.empty?
        end

        results
      end

      def get_field_options
        FIELD_MAPPING.keys.select { |field| field_has_data?(field) }
      end

      def summary_stats
        {
          total_segments: @segments.count,
          available_fields: @available_fields.count,
          fields_with_data: get_field_options.count
        }
      end

      def has_ai_analysis?
        @segments.any? { |segment| segment[""gemini_analysis""] }
      end

      def has_software_detection?
        @segments.any? { |segment| segment[""software_detected""] || segment[""software_detections""] }
      end

      def get_all_topics
        @segments.map { |segment| segment[""topic""] }.compact.uniq
      end

      def get_all_software
        software_list = []

        @segments.each do |segment|
          # Handle software_detections array
          software_list.concat(segment[""software_detections""]) if segment[""software_detections""].is_a?(Array)

          # Handle software_detected string
          software_list << segment[""software_detected""] if segment[""software_detected""]
        end

        software_list.compact.uniq
      end

      def filter_by_topic(topic)
        @segments.select { |segment| segment[""topic""] == topic }
      end

      def filter_by_software(software)
        @segments.select do |segment|
          segment[""software_detected""] == software ||
            (segment[""software_detections""].is_a?(Array) && segment[""software_detections""].include?(software))
        end
      end

      private

      def load_segments_data(file_path)
        data = JSON.parse(File.read(file_path))

        # Handle both array and single segment formats
        data.is_a?(Array) ? data : [data]
      end

      def detect_available_fields
        return [] if @segments.empty?

        all_keys = @segments.flat_map(&:keys).uniq
        all_keys.map { |key| FIELD_MAPPING.key(key) }.compact
      end

      def field_has_data?(field_name)
        json_key = FIELD_MAPPING[field_name]
        return false unless json_key

        @segments.any? { |segment| segment[json_key] && !segment[json_key].to_s.strip.empty? }
      end
    end
  end
end",false
deepgram_formatter.rb,/lib/ComputerTools/wrappers/,"# frozen_string_literal: true

module ComputerTools
  module Wrappers
    class DeepgramFormatter
      def initialize(parser)
        @parser = parser
      end

      def to_srt
        output = []
        @parser.paragraphs.each_with_index do |p, index|
          output << (index + 1).to_s
          output << ""#{format_timestamp_for_srt(p[:start])} --> #{format_timestamp_for_srt(p[:end])}""
          output << p[:text]
          output << """"
        end
        output.join(""\n"")
      end

      def to_markdown
        output = [""# Deepgram Analysis Results\n""]

        output << ""## Full Transcript\n\n#{@parser.transcript}\n"" if @parser.transcript

        unless @parser.paragraphs.empty?
          output << ""## Paragraphs\n""
          @parser.paragraphs.each do |p|
            output << ""### #{p[:start]} -> #{p[:end]}\n""
            output << ""#{p[:text]}\n\n""
          end
        end

        unless @parser.intents.empty?
          output << ""## Intents\n""
          @parser.intents.each do |i|
            output << ""- #{i[:start]} -> #{i[:end]}: #{i[:intent]}\n""
          end
          output << ""\n""
        end

        unless @parser.topics.empty?
          output << ""## Topics\n""
          @parser.topics.each do |t|
            output << ""- #{t[:topic]}\n""
          end
          output << ""\n""
        end

        words = @parser.words_with_confidence
        unless words.empty?
          output << ""## Words with Confidence\n""
          words.each do |w|
            output << ""- #{w[:word]}: #{w[:confidence]}\n""
          end
          output << ""\n""
        end

        sentences = @parser.segmented_sentences
        unless sentences.empty?
          output << ""## Segmented Sentences\n""
          sentences.each do |s|
            output << ""- #{s[:text]}\n""
          end
        end

        output.join(""\n"")
      end

      def to_json(*_args)
        {
          transcript: @parser.transcript,
          paragraphs: @parser.paragraphs,
          intents: @parser.intents,
          topics: @parser.topics,
          words_with_confidence: @parser.words_with_confidence,
          segmented_sentences: @parser.segmented_sentences,
          segments_with_topics: @parser.segments_with_topics,
          segments_with_intents: @parser.segments_with_intents,
          summary_stats: @parser.summary_stats
        }.to_json
      end

      def to_summary
        stats = @parser.summary_stats

        <<~SUMMARY
          üìä Deepgram Analysis Summary
          ============================

          üìù Content Overview:
          ‚Ä¢ Total Words: #{stats[:total_words]}
          ‚Ä¢ Total Sentences: #{stats[:total_sentences]}
          ‚Ä¢ Total Paragraphs: #{stats[:total_paragraphs]}
          ‚Ä¢ Transcript Length: #{stats[:transcript_length]} characters

          üè∑Ô∏è  Topics Identified: #{stats[:total_topics]}
          #{@parser.topics.map { |t| ""   ‚Ä¢ #{t[:topic]}"" }.join(""\n"")}

          üéØ Intents Detected: #{stats[:total_intents]}
          #{@parser.intents.map { |i| ""   ‚Ä¢ #{i[:intent]}"" }.join(""\n"")}

          ‚è±Ô∏è  Duration: #{calculate_duration}
        SUMMARY
      end

      private

      def format_timestamp_for_srt(timestamp_str)
        # Convert HH:MM:SS to HH:MM:SS,000 format for SRT
        return ""00:00:00,000"" unless timestamp_str

        parts = timestamp_str.split(':')
        return ""00:00:00,000"" unless parts.length == 3

        ""#{parts[0]}:#{parts[1]}:#{parts[2]},000""
      end

      def calculate_duration
        return ""Unknown"" if @parser.paragraphs.empty?

        last_paragraph = @parser.paragraphs.last
        last_paragraph[:end] || ""Unknown""
      end
    end
  end
end",false
deepgram_parser.rb,/lib/ComputerTools/wrappers/,"# frozen_string_literal: true

module ComputerTools
  module Wrappers
    class DeepgramParser
      attr_reader :json_data, :paragraphs, :intents, :topics, :transcript

      def initialize(json_file_path)
        raise ArgumentError, ""File not found: #{json_file_path}"" unless File.exist?(json_file_path)

        @json_file_path = json_file_path
        @json_data = load_json_data(json_file_path)
        @paragraphs = []
        @intents = []
        @topics = []
        @transcript = nil

        parse_data
      rescue JSON::ParserError => e
        raise ""Invalid JSON file: #{e.message}""
      end

      def words_with_confidence
        words = @json_data.dig(""results"", ""channels"", 0, ""alternatives"", 0, ""words"")
        return [] unless words

        words.map do |word|
          { word: word[""word""], confidence: word[""confidence""] }
        end
      end

      def segmented_sentences
        paragraphs = @json_data.dig(""results"", ""channels"", 0, ""alternatives"", 0, ""paragraphs"", ""paragraphs"")
        return [] unless paragraphs

        paragraphs
          .flat_map { |p| p[""sentences""] || [] }
          .map { |sentence| { text: sentence[""text""] } }
      end

      def paragraphs_as_sentences
        paragraphs = @json_data.dig(""results"", ""channels"", 0, ""alternatives"", 0, ""paragraphs"", ""paragraphs"")
        return [] unless paragraphs

        paragraphs.map do |p|
          sentences = p[""sentences""] || []
          { paragraph: sentences.map { |s| s[""text""] } }
        end
      end

      def segments_with_topics
        segments = @json_data.dig(""results"", ""topics"", ""segments"")
        return [] unless segments

        segments.map do |seg|
          topics = seg[""topics""] || []
          {
            text: seg[""text""],
            topics: topics.map { |t| { topic: t[""topic""] } }
          }
        end
      end

      def segments_with_intents
        segments = @json_data.dig(""results"", ""intents"", ""segments"")
        return [] unless segments

        segments.map do |seg|
          intents = seg[""intents""] || []
          {
            text: seg[""text""],
            intents: intents.map { |i| { intent: i[""intent""] } }
          }
        end
      end

      def summary_stats
        {
          total_words: words_with_confidence.count,
          total_sentences: segmented_sentences.count,
          total_paragraphs: @paragraphs.count,
          total_topics: @topics.count,
          total_intents: @intents.count,
          transcript_length: @transcript&.length || 0
        }
      end

      private

      def load_json_data(file_path)
        JSON.parse(File.read(file_path))
      end

      def parse_data
        extract_transcript
        extract_paragraphs
        extract_topics
        extract_intents
      end

      def extract_transcript
        @transcript = @json_data.dig(""results"", ""channels"", 0, ""alternatives"", 0, ""transcript"")
      end

      def extract_paragraphs
        paragraphs = @json_data.dig(""results"", ""channels"", 0, ""alternatives"", 0, ""paragraphs"", ""paragraphs"")
        return unless paragraphs

        paragraphs.each do |paragraph|
          sentences = paragraph[""sentences""] || []
          next if sentences.empty?

          sentence_texts = sentences.map { |sentence| sentence[""text""] }
          start_time = format_timestamp(sentences.first[""start""])
          end_time = format_timestamp(sentences.last[""end""])
          @paragraphs << { text: sentence_texts.join("" ""), start: start_time, end: end_time }
        end
      end

      def extract_topics
        segments = @json_data.dig(""results"", ""topics"", ""segments"")
        return unless segments

        segments.each do |seg|
          topics = seg[""topics""]
          next unless topics&.any?

          @topics << { topic: topics[0][""topic""] }
        end
        @topics.uniq!
      end

      def extract_intents
        segments = @json_data.dig(""results"", ""intents"", ""segments"")
        return unless segments

        segments.each do |seg|
          intents = seg[""intents""]
          next unless intents&.any?

          start_time = format_timestamp(seg[""start""])
          end_time = format_timestamp(seg[""end""])
          @intents << { intent: intents[0][""intent""], start: start_time, end: end_time }
        end
        @intents.uniq!
      end

      def format_timestamp(seconds, include_ms: false)
        return nil if seconds.nil?

        hours = (seconds / 3600).to_i
        minutes = ((seconds % 3600) / 60).to_i
        secs = (seconds % 60).to_i
        ms = ((seconds % 1) * 1000).to_i

        if include_ms
          format(""%02d:%02d:%02d,%03d"", hours, minutes, secs, ms)
        else
          format(""%02d:%02d:%02d"", hours, minutes, secs)
        end
      rescue StandardError => e
        puts ""Error formatting timestamp: #{e.message}""
        nil
      end
    end
  end
end",false
docling.rb,/lib/ComputerTools/wrappers/,"# frozen_string_literal: true

module ComputerTools
  module Wrappers
    # A Terrapin-based DSL wrapper for the docling CLI tool that provides a fluent interface
    # for converting documents between formats and processing them with various options.
    #
    # This class abstracts the docling command-line interface into a Ruby-friendly builder pattern,
    # allowing for method chaining to configure document processing options.
    #
    # @example Basic usage converting a PDF to Markdown
    #   runner = Docling.new
    #     .from_format('pdf')
    #     .to_markdown
    #     .run('document.pdf')
    #
    # @example Advanced usage with multiple options
    #   runner = Docling.new
    #     .from_format('docx')
    #     .to_html
    #     .image_embedded
    #     .ocr(true)
    #     .verbose(2)
    #     .run('document.docx')
    class Docling
      # Initializes a new Docling instance and validates that the docling CLI is available.
      #
      # @raise [StandardError] if docling CLI is not found in the system path
      def initialize
        @line = Terrapin::CommandLine.new('docling', ':options :source')
        @options = {}
        validate_docling_available
      end

      # Specifies the input document format.
      #
      # @param [String] format The input format (e.g., 'pdf', 'docx')
      # @return [Docling] self for method chaining
      def from_format(format)
        @options[:from] = format
        self
      end

      # Specifies the output document format.
      #
      # @param [String] format The output format (e.g., 'md', 'html')
      # @return [Docling] self for method chaining
      def to_format(format)
        @options[:to] = format
        self
      end

      # Sets the output format to Markdown.
      #
      # @return [Docling] self for method chaining
      def to_markdown
        @options[:to] = 'md'
        self
      end

      # Sets the output format to JSON.
      #
      # @return [Docling] self for method chaining
      def to_json(*_args)
        @options[:to] = 'json'
        self
      end

      # Sets the output format to HTML.
      #
      # @return [Docling] self for method chaining
      def to_html
        @options[:to] = 'html'
        self
      end

      # Sets the output format to plain text.
      #
      # @return [Docling] self for method chaining
      def to_text
        @options[:to] = 'text'
        self
      end

      # Enables or disables layout visualization in the output.
      #
      # @param [Boolean] enabled Whether to show layout (default: true)
      # @return [Docling] self for method chaining
      def show_layout(enabled=true)
        @options[:'show-layout'] = enabled
        self
      end

      # Sets HTTP headers for URL sources.
      #
      # @param [String] headers_json JSON string containing HTTP headers
      # @return [Docling] self for method chaining
      def headers(headers_json)
        @options[:headers] = headers_json
        self
      end

      # Sets the image export mode with a specific value.
      #
      # @param [String] mode The export mode ('placeholder', 'embedded', or 'referenced')
      # @return [Docling] self for method chaining
      def image_export_mode(mode)
        @options[:'image-export-mode'] = mode
        self
      end

      # Sets image export mode to use placeholders.
      #
      # @return [Docling] self for method chaining
      def image_placeholder
        @options[:'image-export-mode'] = 'placeholder'
        self
      end

      # Sets image export mode to embed images directly.
      #
      # @return [Docling] self for method chaining
      def image_embedded
        @options[:'image-export-mode'] = 'embedded'
        self
      end

      # Sets image export mode to reference external image files.
      #
      # @return [Docling] self for method chaining
      def image_referenced
        @options[:'image-export-mode'] = 'referenced'
        self
      end

      # Sets the processing pipeline type.
      #
      # @param [String] type The pipeline type ('standard', 'vlm', or 'asr')
      # @return [Docling] self for method chaining
      def pipeline(type)
        @options[:pipeline] = type
        self
      end

      # Sets the pipeline to use the standard processing pipeline.
      #
      # @return [Docling] self for method chaining
      def standard_pipeline
        @options[:pipeline] = 'standard'
        self
      end

      # Sets the pipeline to use the VLM (Vision-Language Model) pipeline.
      #
      # @return [Docling] self for method chaining
      def vlm_pipeline
        @options[:pipeline] = 'vlm'
        self
      end

      # Sets the pipeline to use the ASR (Automatic Speech Recognition) pipeline.
      #
      # @return [Docling] self for method chaining
      def asr_pipeline
        @options[:pipeline] = 'asr'
        self
      end

      # Sets the VLM model to use for processing.
      #
      # @param [String] model The VLM model identifier
      # @return [Docling] self for method chaining
      def vlm_model(model)
        @options[:'vlm-model'] = model
        self
      end

      # Sets the ASR model to use for processing.
      #
      # @param [String] model The ASR model identifier
      # @return [Docling] self for method chaining
      def asr_model(model)
        @options[:'asr-model'] = model
        self
      end

      # Enables or disables OCR (Optical Character Recognition).
      #
      # @param [Boolean] enabled Whether to enable OCR (default: true)
      # @return [Docling] self for method chaining
      def ocr(enabled=true)
        @options[:ocr] = enabled
        self
      end

      # Enables or disables forced OCR processing.
      #
      # @param [Boolean] enabled Whether to force OCR (default: true)
      # @return [Docling] self for method chaining
      def force_ocr(enabled=true)
        @options[:'force-ocr'] = enabled
        self
      end

      # Sets the OCR engine to use.
      #
      # @param [String] engine The OCR engine identifier
      # @return [Docling] self for method chaining
      def ocr_engine(engine)
        @options[:'ocr-engine'] = engine
        self
      end

      # Sets the languages for OCR processing.
      #
      # @param [String, Array<String>] languages Language codes for OCR
      # @return [Docling] self for method chaining
      def ocr_lang(languages)
        @options[:'ocr-lang'] = languages
        self
      end

      # Sets the PDF backend to use for processing.
      #
      # @param [String] backend The PDF backend identifier
      # @return [Docling] self for method chaining
      def pdf_backend(backend)
        @options[:'pdf-backend'] = backend
        self
      end

      # Sets the table processing mode.
      #
      # @param [String] mode The table processing mode ('fast' or 'accurate')
      # @return [Docling] self for method chaining
      def table_mode(mode)
        @options[:'table-mode'] = mode
        self
      end

      # Sets table processing to fast mode.
      #
      # @return [Docling] self for method chaining
      def table_fast
        @options[:'table-mode'] = 'fast'
        self
      end

      # Sets table processing to accurate mode.
      #
      # @return [Docling] self for method chaining
      def table_accurate
        @options[:'table-mode'] = 'accurate'
        self
      end

      # Enables or disables code enrichment in the output.
      #
      # @param [Boolean] enabled Whether to enrich code (default: true)
      # @return [Docling] self for method chaining
      def enrich_code(enabled=true)
        @options[:'enrich-code'] = enabled
        self
      end

      # Enables or disables formula enrichment in the output.
      #
      # @param [Boolean] enabled Whether to enrich formulas (default: true)
      # @return [Docling] self for method chaining
      def enrich_formula(enabled=true)
        @options[:'enrich-formula'] = enabled
        self
      end

      # Enables or disables picture class enrichment in the output.
      #
      # @param [Boolean] enabled Whether to enrich picture classes (default: true)
      # @return [Docling] self for method chaining
      def enrich_picture_classes(enabled=true)
        @options[:'enrich-picture-classes'] = enabled
        self
      end

      # Enables or disables picture description enrichment in the output.
      #
      # @param [Boolean] enabled Whether to enrich picture descriptions (default: true)
      # @return [Docling] self for method chaining
      def enrich_picture_description(enabled=true)
        @options[:'enrich-picture-description'] = enabled
        self
      end

      # Sets the path for storing processing artifacts.
      #
      # @param [String] path The directory path for artifacts
      # @return [Docling] self for method chaining
      def artifacts_path(path)
        @options[:'artifacts-path'] = path
        self
      end

      # Enables or disables remote services.
      #
      # @param [Boolean] enabled Whether to enable remote services (default: true)
      # @return [Docling] self for method chaining
      def enable_remote_services(enabled=true)
        @options[:'enable-remote-services'] = enabled
        self
      end

      # Enables or disables external plugins.
      #
      # @param [Boolean] enabled Whether to allow external plugins (default: true)
      # @return [Docling] self for method chaining
      def allow_external_plugins(enabled=true)
        @options[:'allow-external-plugins'] = enabled
        self
      end

      # Enables or disables showing external plugins.
      #
      # @param [Boolean] enabled Whether to show external plugins (default: true)
      # @return [Docling] self for method chaining
      def show_external_plugins(enabled=true)
        @options[:'show-external-plugins'] = enabled
        self
      end

      # Enables or disables aborting on errors.
      #
      # @param [Boolean] enabled Whether to abort on errors (default: true)
      # @return [Docling] self for method chaining
      def abort_on_error(enabled=true)
        @options[:'abort-on-error'] = enabled
        self
      end

      # Sets the output directory for processed files.
      #
      # @param [String] path The output directory path
      # @return [Docling] self for method chaining
      def output_dir(path)
        @options[:output] = path
        self
      end

      # Sets the verbosity level for processing.
      #
      # @param [Integer] level The verbosity level (default: 1)
      # @return [Docling] self for method chaining
      def verbose(level=1)
        @options[:verbose] = level
        self
      end

      # Enables or disables cell visualization debugging.
      #
      # @param [Boolean] enabled Whether to visualize cells (default: true)
      # @return [Docling] self for method chaining
      def debug_visualize_cells(enabled=true)
        @options[:'debug-visualize-cells'] = enabled
        self
      end

      # Enables or disables OCR visualization debugging.
      #
      # @param [Boolean] enabled Whether to visualize OCR (default: true)
      # @return [Docling] self for method chaining
      def debug_visualize_ocr(enabled=true)
        @options[:'debug-visualize-ocr'] = enabled
        self
      end

      # Enables or disables layout visualization debugging.
      #
      # @param [Boolean] enabled Whether to visualize layout (default: true)
      # @return [Docling] self for method chaining
      def debug_visualize_layout(enabled=true)
        @options[:'debug-visualize-layout'] = enabled
        self
      end

      # Enables or disables table visualization debugging.
      #
      # @param [Boolean] enabled Whether to visualize tables (default: true)
      # @return [Docling] self for method chaining
      def debug_visualize_tables(enabled=true)
        @options[:'debug-visualize-tables'] = enabled
        self
      end

      # Sets the document processing timeout in seconds.
      #
      # @param [Integer] seconds The timeout duration in seconds
      # @return [Docling] self for method chaining
      def document_timeout(seconds)
        @options[:'document-timeout'] = seconds
        self
      end

      # Sets the number of threads to use for processing.
      #
      # @param [Integer] count The number of threads
      # @return [Docling] self for method chaining
      def num_threads(count)
        @options[:'num-threads'] = count
        self
      end

      # Sets the processing device to use.
      #
      # @param [String] device_type The device type ('cpu', 'cuda', or 'auto')
      # @return [Docling] self for method chaining
      def device(device_type)
        @options[:device] = device_type
        self
      end

      # Sets the processing device to use CPU.
      #
      # @return [Docling] self for method chaining
      def use_cpu
        @options[:device] = 'cpu'
        self
      end

      # Sets the processing device to use CUDA.
      #
      # @return [Docling] self for method chaining
      def use_cuda
        @options[:device] = 'cuda'
        self
      end

      # Sets the processing device to auto-detect.
      #
      # @return [Docling] self for method chaining
      def use_auto
        @options[:device] = 'auto'
        self
      end

      # Executes the configured docling command on the specified source file.
      #
      # @param [String] source_path The path to the source document to process
      # @return [String] The processed output from docling
      # @raise [StandardError] If the docling command fails to execute
      # @example Processing a PDF document
      #   runner = Docling.new.to_markdown
      #   result = runner.run('document.pdf')
      def run(source_path)
        options_string = build_options_string
        @line.run(options: options_string, source: source_path)
      rescue Terrapin::ExitStatusError => e
        raise StandardError, ""Docling failed: #{e.message}""
      end

      private

      # Validates that the docling CLI is available in the system path.
      #
      # @raise [StandardError] if docling is not found
      def validate_docling_available
        return if system('which docling > /dev/null 2>&1')

        raise StandardError, 'docling CLI not found. Install with: pip install docling'
      end

      # Builds the options string for the docling command from the configured options.
      #
      # @return [String] The formatted options string
      def build_options_string
        options_parts = []
        @options.each do |key, value|
          flag = ""--#{key.to_s.tr('_', '-')}""
          if value.is_a?(TrueClass)
            options_parts << flag
          elsif value.is_a?(FalseClass)
            options_parts << ""--no-#{key.to_s.tr('_', '-')}""
          elsif value
            options_parts << ""#{flag} #{value}""
          end
        end
        options_parts.join(' ')
      end
    end

    # Processes various document formats into standardized outputs.
    #
    # This class handles the conversion of supported document formats (PDF, DOCX, etc.)
    # into processed outputs using the Docling.
    #
    # @example Processing a document file
    #   processor = FilesDB::Processors::Document.new
    #   result = processor.process('document.pdf')
    class Document
      # Processes a document file based on its extension.
      #
      # @param [String] file_path The path to the document file to process
      # @return [String] The processed document content, or empty string on failure
      # @example Processing a PDF file
      #   processor = FilesDB::Processors::Document.new
      #   markdown = processor.process('report.pdf')
      def process(file_path)
        unless File.exist?(file_path)
          log_error(""File not found: #{file_path}"")
          return ''
        end

        case File.extname(file_path).downcase
        when '.pdf', '.docx', '.doc', '.odt'
          process_with_docling(file_path)
        else
          log_error(""Unsupported document format: #{file_path}"")
          ''
        end
      end

      private

      # Processes a document file using the Docling with default settings.
      #
      # @param [String] file_path The path to the document file to process
      # @return [String] The processed document content
      def process_with_docling(file_path)
        runner = Docling.new
          .to_markdown
          .image_referenced
          .table_accurate
          .ocr(true)

        runner.run(file_path)
      rescue StandardError => e
        log_error(""Failed to process document #{file_path}: #{e.message}"")
        ''
      end

      # Simple logging method
      def log_error(message)
        puts ""‚ùå #{message}"".colorize(:red)
      end
    end
  end
end",false
git_wrapper.rb,/lib/ComputerTools/wrappers/,"# frozen_string_literal: true

module ComputerTools
  module Wrappers
    class GitWrapper
      def initialize
        @repositories = {}
      end

      def open_repository(path)
        return @repositories[path] if @repositories[path]

        begin
          @repositories[path] = Git.open(path)
        rescue Git::Error => e
          puts ""‚ö†Ô∏è  Warning: Could not open Git repository at #{path}: #{e.message}"".colorize(:yellow)
          nil
        end
      end

      def get_file_status(git, file_path)
        git_status = git.status

        if git_status.added.include?(file_path)
          { raw_status: 'A ', index: 'Added', worktree: 'Unchanged' }
        elsif git_status.changed.include?(file_path)
          { raw_status: ' M', index: 'Unchanged', worktree: 'Modified' }
        elsif git_status.deleted.include?(file_path)
          { raw_status: ' D', index: 'Unchanged', worktree: 'Deleted' }
        elsif git_status.untracked.include?(file_path)
          { raw_status: '??', index: 'Unchanged', worktree: 'Untracked' }
        else
          { raw_status: '--', index: 'Clean', worktree: 'Clean' }
        end
      rescue Git::Error => e
        puts ""‚ö†Ô∏è  Warning: Could not get status for #{file_path}: #{e.message}"".colorize(:yellow)
        { raw_status: '--', index: 'Error', worktree: 'Error' }
      end

      def get_file_diff(git, file_path)
        # For untracked files, we can't diff against HEAD
        return { additions: 0, deletions: 0, chunks: 0 } if git.status.untracked.include?(file_path)

        diff = git.diff('HEAD', file_path)

        if diff.size > 0
          file_diff = diff.first
          {
            additions: file_diff.patch ? file_diff.patch.scan(/^\+[^+]/).length : 0,
            deletions: file_diff.patch ? file_diff.patch.scan(/^-[^-]/).length : 0,
            chunks: file_diff.patch ? file_diff.patch.scan(/^@@/).length : 0
          }
        else
          { additions: 0, deletions: 0, chunks: 0 }
        end
      rescue Git::Error => e
        puts ""‚ö†Ô∏è  Warning: Could not get diff for #{file_path}: #{e.message}"".colorize(:yellow) if ENV['DEBUG']
        { additions: 0, deletions: 0, chunks: 0 }
      end

      def repository_exists?(path)
        File.directory?(File.join(path, '.git'))
      end

      def find_repository_root(file_path)
        dir = File.dirname(file_path)

        while dir != '/'
          return dir if repository_exists?(dir)

          dir = File.dirname(dir)
        end

        nil
      end

      def file_tracked?(git, file_path)
        !git.status.untracked.include?(file_path)
      rescue Git::Error
        false
      end

      def get_recent_commits(git, limit: 10)
        git.log(limit).map do |commit|
          {
            sha: commit.sha,
            message: commit.message,
            author: commit.author.name,
            date: commit.date
          }
        end
      rescue Git::Error => e
        puts ""‚ö†Ô∏è  Warning: Could not get recent commits: #{e.message}"".colorize(:yellow)
        []
      end

      def get_branch_name(git)
        git.current_branch
      rescue Git::Error
        'unknown'
      end

      def is_dirty?(git)
        !git.status.changed.empty? || !git.status.added.empty? || !git.status.deleted.empty?
      rescue Git::Error
        false
      end

      def get_uncommitted_changes_count(git)
        status = git.status
        {
          modified: status.changed.count,
          added: status.added.count,
          deleted: status.deleted.count,
          untracked: status.untracked.count
        }
      rescue Git::Error
        { modified: 0, added: 0, deleted: 0, untracked: 0 }
      end
    end
  end
end",false
restic_wrapper.rb,/lib/ComputerTools/wrappers/,"# frozen_string_literal: true

module ComputerTools
  module Wrappers
    class ResticWrapper
      attr_reader :config, :mount_point, :repository

      def initialize(config)
        @config = config
        @mount_point = config.fetch(:paths, :restic_mount_point) || File.expand_path('~/mnt/restic')
        @repository = config.fetch(:paths, :restic_repo) || ENV['RESTIC_REPOSITORY'] || '/path/to/restic/repo'
        @mounted = false
        @mount_pid = nil
        @home_dir = config.fetch(:paths, :home_dir) || File.expand_path('~')

        setup_cleanup_handler
      end

      def ensure_mounted
        return true if mounted?

        puts ""üì¶ Restic backup not mounted. Attempting to mount..."".colorize(:blue)
        mount_backup
      end

      def mounted?
        File.directory?(@mount_point) && !Dir.empty?(@mount_point)
      end

      def snapshot_path
        File.join(@mount_point, 'snapshots', 'latest', 'home', File.basename(@home_dir))
      end

      def mount_backup
        unless TTY::Which.exist?('restic')
          puts ""‚ùå 'restic' command not found. Please install restic."".colorize(:red)
          return false
        end

        # FileUtils.mkdir_p(@mount_point) unless File.directory?(@mount_point)

        puts ""üîê Mounting restic repository..."".colorize(:blue)
        puts ""   Repository: #{@repository}"".colorize(:cyan)
        puts ""   Mount point: #{@mount_point}"".colorize(:cyan)
        puts ""   Note: You will be prompted for the repository passphrase"".colorize(:yellow)

        fork do
          `kitty -e restic mount -r #{@repository} #{@mount_point}`
        end

        sleep 20

        if $?.success?
          puts ""‚úÖ Restic repository mounted successfully."".colorize(:green)
          @mounted = true
          @mount_pid = $?.pid
        else
          puts ""‚ùå Failed to mount restic repository: #{result.error}"".colorize(:red)
          puts ""   Please check the repository path and passphrase."".colorize(:yellow)
          false
        end
      rescue StandardError => e
        puts ""‚ùå Error mounting restic backup: #{e.message}"".colorize(:red)
        false
      end

      def compare_with_snapshot(current_file, snapshot_file)
        unless TTY::Which.exist?('diff')
          puts ""‚ö†Ô∏è  Warning: 'diff' command not found. Cannot compare files."".colorize(:yellow)
          return { changed: false, additions: 0, deletions: 0, chunks: 0 }
        end

        stdout, _, status = Open3.capture3(""diff -u \""#{snapshot_file}\"" \""#{current_file}\"""")

        if status.exitstatus == 0
          { changed: false, additions: 0, deletions: 0, chunks: 0 }
        else
          {
            changed: true,
            additions: stdout.scan(/^\+[^+]/).length,
            deletions: stdout.scan(/^-[^-]/).length,
            chunks: stdout.scan(/^@@/).length
          }
        end
      rescue StandardError => e
        puts ""‚ö†Ô∏è  Warning: Could not compare files: #{e.message}"".colorize(:yellow)
        { changed: false, additions: 0, deletions: 0, chunks: 0 }
      end

      def unmount
        return unless mounted?

        puts ""üîí Unmounting restic repository..."".colorize(:blue)

        if TTY::Which.exist?('umount')
          if system(""umount '#{@mount_point}' 2>/dev/null"")
            puts ""‚úÖ Restic repository unmounted successfully."".colorize(:green)
            @mounted = false
          else
            puts ""‚ö†Ô∏è  Warning: Could not unmount #{@mount_point}"".colorize(:yellow)
            puts ""   Please manually unmount or terminate the restic process with Ctrl+C"".colorize(:yellow)
          end
        else
          puts ""‚ö†Ô∏è  Warning: 'umount' command not available."".colorize(:yellow)
          puts ""   Please manually unmount #{@mount_point}"".colorize(:yellow)
          puts ""   Or terminate the restic process in the terminal with Ctrl+C"".colorize(:yellow)
        end
      end

      def cleanup
        unmount if mounted?
      end

      private

      # def wait_for_mount
      #   mount_timeout = @config.fetch(:restic, :mount_timeout) || 60

      #   mount_timeout.times do |i|
      #     sleep 1

      #     if mounted?
      #       puts ""\n‚úÖ Mount point is ready!"".colorize(:green)
      #       @mounted = true
      #       return true
      #     end

      #     # Show progress every 5 seconds
      #     puts ""   Still waiting... (#{i}/#{mount_timeout}s)"".colorize(:cyan) if i % 5 == 0
      #   end

      #   puts ""\n‚ùå Timeout waiting for mount point."".colorize(:red)
      #   puts ""   Please ensure the restic repository is mounted successfully."".colorize(:red)
      #   puts ""   Check the terminal window for any error messages."".colorize(:yellow)
      #   false
      # end

      def detect_terminal_emulator
        command = @config.fetch(:terminal, :command) || 'kitty'
        args = @config.fetch(:terminal, :args) || '-e'

        return nil unless TTY::Which.exist?(command)

        ""#{command} #{args}""
      end

      def setup_cleanup_handler
        at_exit { cleanup }
      end
    end
  end
end",false
trafilatura.rb,/lib/ComputerTools/wrappers/,"# frozen_string_literal: true

module ComputerTools
  module Wrappers
    # A Terrapin-based DSL wrapper for the trafilatura CLI tool that provides a fluent interface
    # for HTML/XML content extraction and processing. This class enables Ruby developers to
    # programmatically interact with trafilatura's powerful web scraping and content extraction
    # capabilities through a clean, chainable API.
    #
    # The class handles command construction, option validation, and execution of the trafilatura
    # command-line tool, abstracting away the complexity of direct CLI interaction while providing
    # full access to all trafilatura features.
    #
    # @example Basic usage for extracting content from a URL
    #   Trafilatura.new
    #     .url('https://example.com')
    #     .formatting
    #     .run
    #
    # @example Processing multiple files with output formatting
    #   Trafilatura.new
    #     .input_dir('path/to/files')
    #     .output_dir('path/to/output')
    #     .markdown
    #     .run
    #
    # @note Requires trafilatura to be installed and available in the system PATH
    # @see https://trafilatura.readthedocs.io/en/latest/ Trafilatura documentation
    class Trafilatura
      # Initializes a new Trafilatura instance and validates that trafilatura is available
      # in the system.
      #
      # @raise [StandardError] if trafilatura is not found in the system PATH
      def initialize
        @line = Terrapin::CommandLine.new('trafilatura', ':options :source')
        @options = {}
        validate_trafilatura_available
      end

      # Specifies an input file to process
      #
      # @param [String] file_path Path to the input file
      # @return [Trafilatura] self for method chaining
      def input_file(file_path)
        @options[:'input-file'] = file_path
        self
      end

      # Specifies an input directory to process
      #
      # @param [String] dir_path Path to the input directory
      # @return [Trafilatura] self for method chaining
      def input_dir(dir_path)
        @options[:'input-dir'] = dir_path
        self
      end

      # Specifies a URL to process
      #
      # @param [String] url The URL to fetch and process
      # @return [Trafilatura] self for method chaining
      def url(url)
        @options[:URL] = url
        self
      end

      # Enables parallel processing with the specified number of workers
      #
      # @param [Integer] count Number of parallel workers to use
      # @return [Trafilatura] self for method chaining
      def parallel(count)
        @options[:parallel] = count
        self
      end

      # Specifies a blacklist file containing URLs or patterns to exclude
      #
      # @param [String] file_path Path to the blacklist file
      # @return [Trafilatura] self for method chaining
      def blacklist(file_path)
        @options[:blacklist] = file_path
        self
      end

      # Lists files without processing them
      #
      # @return [Trafilatura] self for method chaining
      def list_only
        @options[:list] = true
        self
      end

      # Specifies an output directory for processed files
      #
      # @param [String] dir_path Path to the output directory
      # @return [Trafilatura] self for method chaining
      def output_dir(dir_path)
        @options[:'output-dir'] = dir_path
        self
      end

      # Specifies a backup directory for original files
      #
      # @param [String] dir_path Path to the backup directory
      # @return [Trafilatura] self for method chaining
      def backup_dir(dir_path)
        @options[:'backup-dir'] = dir_path
        self
      end

      # Preserves directory structure in output
      #
      # @return [Trafilatura] self for method chaining
      def keep_dirs
        @options[:'keep-dirs'] = true
        self
      end

      # Processes content from a feed (RSS/Atom)
      #
      # @param [String, nil] url Optional URL of the feed to process
      # @return [Trafilatura] self for method chaining
      def feed(url=nil)
        @options[:feed] = url || true
        self
      end

      # Processes content from a sitemap
      #
      # @param [String, nil] url Optional URL of the sitemap to process
      # @return [Trafilatura] self for method chaining
      def sitemap(url=nil)
        @options[:sitemap] = url || true
        self
      end

      # Enables crawling mode with optional depth limit
      #
      # @param [Integer, nil] count Optional maximum number of pages to crawl
      # @return [Trafilatura] self for method chaining
      def crawl(count=nil)
        @options[:crawl] = count || true
        self
      end

      # Explores links found in the processed content
      #
      # @param [String, nil] url Optional base URL for exploration
      # @return [Trafilatura] self for method chaining
      def explore(url=nil)
        @options[:explore] = url || true
        self
      end

      # Probes URLs to check their availability and content type
      #
      # @param [String, nil] url Optional URL to probe
      # @return [Trafilatura] self for method chaining
      def probe(url=nil)
        @options[:probe] = url || true
        self
      end

      # Processes archived web pages
      #
      # @return [Trafilatura] self for method chaining
      def archived
        @options[:archived] = true
        self
      end

      # Filters URLs based on the provided patterns
      #
      # @param [Array<String>] patterns URL patterns to filter by
      # @return [Trafilatura] self for method chaining
      def url_filter(*patterns)
        @options[:'url-filter'] = patterns.join(' ')
        self
      end

      # Enables fast processing mode (less accurate but faster)
      #
      # @return [Trafilatura] self for method chaining
      def fast
        @options[:fast] = true
        self
      end

      # Preserves formatting in the output
      #
      # @return [Trafilatura] self for method chaining
      def formatting
        @options[:formatting] = true
        self
      end

      # Includes links in the output
      #
      # @return [Trafilatura] self for method chaining
      def links
        @options[:links] = true
        self
      end

      # Includes images in the output
      #
      # @return [Trafilatura] self for method chaining
      def images
        @options[:images] = true
        self
      end

      # Excludes comments from the output
      #
      # @return [Trafilatura] self for method chaining
      def no_comments
        @options[:'no-comments'] = true
        self
      end

      # Excludes tables from the output
      #
      # @return [Trafilatura] self for method chaining
      def no_tables
        @options[:'no-tables'] = true
        self
      end

      # Processes only documents with metadata
      #
      # @return [Trafilatura] self for method chaining
      def only_with_metadata
        @options[:'only-with-metadata'] = true
        self
      end

      # Includes metadata in the output
      #
      # @return [Trafilatura] self for method chaining
      def with_metadata
        @options[:'with-metadata'] = true
        self
      end

      # Sets the target language for content extraction
      #
      # @param [String] lang_code ISO language code (e.g., 'en', 'fr')
      # @return [Trafilatura] self for method chaining
      def target_language(lang_code)
        @options[:'target-language'] = lang_code
        self
      end

      # Enables deduplication of content
      #
      # @return [Trafilatura] self for method chaining
      def deduplicate
        @options[:deduplicate] = true
        self
      end

      # Specifies a configuration file to use
      #
      # @param [String] file_path Path to the configuration file
      # @return [Trafilatura] self for method chaining
      def config_file(file_path)
        @options[:'config-file'] = file_path
        self
      end

      # Optimizes for precision (may be slower)
      #
      # @return [Trafilatura] self for method chaining
      def precision
        @options[:precision] = true
        self
      end

      # Optimizes for recall (may be less precise)
      #
      # @return [Trafilatura] self for method chaining
      def recall
        @options[:recall] = true
        self
      end

      # Sets the output format for the processed content
      #
      # @param [String] format Output format (e.g., 'txt', 'html', 'json')
      # @return [Trafilatura] self for method chaining
      def output_format(format)
        @options[:'output-format'] = format
        self
      end

      # Sets output format to CSV
      #
      # @return [Trafilatura] self for method chaining
      def csv
        @options[:csv] = true
        self
      end

      # Sets output format to HTML
      #
      # @return [Trafilatura] self for method chaining
      def html
        @options[:html] = true
        self
      end

      # Sets output format to JSON
      #
      # @return [Trafilatura] self for method chaining
      def json
        @options[:json] = true
        self
      end

      # Sets output format to Markdown
      #
      # @return [Trafilatura] self for method chaining
      def markdown
        @options[:markdown] = true
        self
      end

      # Sets output format to XML
      #
      # @return [Trafilatura] self for method chaining
      def xml
        @options[:xml] = true
        self
      end

      # Sets output format to XML-TEI
      #
      # @return [Trafilatura] self for method chaining
      def xmltei
        @options[:xmltei] = true
        self
      end

      # Validates TEI output
      #
      # @return [Trafilatura] self for method chaining
      def validate_tei
        @options[:'validate-tei'] = true
        self
      end

      # Sets the verbosity level for output
      #
      # @param [Integer] level Verbosity level (default: 1)
      # @return [Trafilatura] self for method chaining
      def verbose(level=1)
        @options[:verbose] = level
        self
      end

      # Executes the trafilatura command with the configured options
      #
      # @param [String, nil] source_input Optional direct input string to process
      # @return [String] The output from the trafilatura command
      # @raise [StandardError] If the trafilatura command fails
      # @example Processing a URL
      #   Trafilatura.new.url('https://example.com').run
      # @example Processing a file
      #   Trafilatura.new.input_file('document.html').run
      # @example Processing direct input
      #   html_content = '<html>...</html>'
      #   Trafilatura.new.run(html_content)
      def run(source_input=nil)
        options_string = build_options_string
        if source_input
          result = @line.run(options: options_string, source: source_input)
        else
          # For cases where input is specified via options (like --input-file)
          command = Terrapin::CommandLine.new('trafilatura', ':options')
          result = command.run(options: options_string)
        end
        result
      rescue Terrapin::ExitStatusError => e
        raise StandardError, ""Trafilatura failed: #{e.message}""
      end

      private

      # Validates that trafilatura is available in the system PATH
      #
      # @raise [StandardError] if trafilatura is not found
      def validate_trafilatura_available
        return if system('which trafilatura > /dev/null 2>&1')

        raise StandardError, 'trafilatura CLI not found. Install with: pip install trafilatura'
      end

      # Builds the options string for the trafilatura command
      #
      # @return [String] The constructed options string
      def build_options_string
        options_parts = []
        @options.each do |key, value|
          flag = ""--#{key.to_s.tr('_', '-')}""

          if value.is_a?(TrueClass)
            options_parts << flag
          elsif value.is_a?(FalseClass)
            # Skip false values
            next
          elsif value && value != true
            options_parts << ""#{flag} #{value}""
          end
        end
        options_parts.join(' ')
      end
    end
  end
end",false
ComputerTools.rb,/lib/,"#!/usr/bin/env ruby
lib_dir = File.expand_path(File.join(__dir__, "".."", ""lib""))
$:.unshift lib_dir unless $:.include?(lib_dir)

require 'colorize'
require 'fileutils'
require 'git'
require 'json'
require 'net/http'
require 'open3'
require 'pg'
require 'sequel'
require 'sublayer'
require 'tempfile'
require 'terrapin'
require 'thor'
require 'time'
require 'tty-command'
require 'tty-config'
require 'tty-file'
require 'tty-logger'
require 'tty-prompt'
require 'tty-table'
require 'tty-which'
require 'uri'
require 'yaml'

require ""ComputerTools/version""
require ""ComputerTools/config""
require ""ComputerTools/logger""
require ""ComputerTools/configuration""

require ""ComputerTools/providers/sublayer/ollama""
require ""ComputerTools/providers/sublayer/openrouter""

require ""ComputerTools/actions/blueprint/blueprint_config_action""
require ""ComputerTools/actions/blueprint/blueprint_edit_action""
require ""ComputerTools/actions/blueprint/blueprint_list_action""
require ""ComputerTools/actions/blueprint/blueprint_search_action""
require ""ComputerTools/actions/blueprint/blueprint_delete_action""
require ""ComputerTools/actions/blueprint/blueprint_export_action""
require ""ComputerTools/actions/blueprint/blueprint_submit_action""
require ""ComputerTools/actions/blueprint/blueprint_view_action""

require ""ComputerTools/actions/deepgram/deepgram_analyze_action""
require ""ComputerTools/actions/deepgram/deepgram_config_action""
require ""ComputerTools/actions/deepgram/deepgram_convert_action""
require ""ComputerTools/actions/deepgram/deepgram_parse_action""

require ""ComputerTools/actions/file_activity/file_discovery_action""
require ""ComputerTools/actions/file_activity/git_analysis_action""
require ""ComputerTools/actions/file_activity/latest_changes_action""
require ""ComputerTools/actions/file_activity/restic_analysis_action""
require ""ComputerTools/actions/file_activity/yadm_analysis_action""

require ""ComputerTools/wrappers/blueprint_database""
require ""ComputerTools/wrappers/deepgram_analyzer""
require ""ComputerTools/wrappers/deepgram_formatter""
require ""ComputerTools/wrappers/deepgram_parser""
require ""ComputerTools/wrappers/docling""
require ""ComputerTools/wrappers/git_wrapper""
require ""ComputerTools/wrappers/restic_wrapper""
require ""ComputerTools/wrappers/trafilatura""

require ""ComputerTools/commands/base_command""
require ""ComputerTools/commands/menu_command""
require ""ComputerTools/commands/blueprint_command""
require ""ComputerTools/commands/config_command""
require ""ComputerTools/commands/deepgram_command""
require ""ComputerTools/commands/latest_changes_command""
require ""ComputerTools/commands/overview_command""

require 'ComputerTools/generators/blueprint/blueprint_category_generator'
require 'ComputerTools/generators/blueprint/blueprint_description_generator'
require 'ComputerTools/generators/blueprint/blueprint_improvement_generator'
require 'ComputerTools/generators/blueprint/blueprint_name_generator'

require ""ComputerTools/generators/deepgram/deepgram_insights_generator""
require ""ComputerTools/generators/deepgram/deepgram_summary_generator""
require ""ComputerTools/generators/deepgram/deepgram_topics_generator""

require ""ComputerTools/generators/file_activity/file_activity_report_generator""

require ""ComputerTools/generators/overview_generator""

Dir[File.join(__dir__, ""ComputerTools"", ""agents"", ""*.rb"")].each { |file| require file }

require_relative ""ComputerTools/cli""

module ComputerTools
  class Error < StandardError; end
  Config.load

  # Provides global access to the logger instance
  def self.logger
    ComputerTools::Logger.instance
  end

  def self.root
    File.dirname __dir__
  end
end",false
